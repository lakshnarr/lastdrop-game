<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Last Drop &#128167; Demo Mode</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --bg-color: #050711;
      --accent: #40e0d0;
      --accent-soft: rgba(64, 224, 208, 0.3);
      --card-bg: #0b1020;
      --tile-bg: #111827;
      --tile-border: #1f2937;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --danger: #f97373;
      --success: #4ade80;
    }

    * {
      box-sizing: border-box;
    }

    html {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111827 0, var(--bg-color) 55%);
      color: var(--text-main);
      height: 100vh;
      overflow: hidden;
      display: grid;
      grid-template-rows: auto 1fr auto;
      grid-template-areas: 
        "header"
        "main"
        "footer";
      -webkit-overflow-scrolling: touch;
    }

    /* Scrollbar styling */
    .side-card::-webkit-scrollbar,
    .settings-content::-webkit-scrollbar {
      width: 6px;
    }

    .side-card::-webkit-scrollbar-track,
    .settings-content::-webkit-scrollbar-track {
      background: rgba(15, 23, 42, 0.3);
    }

    .side-card::-webkit-scrollbar-thumb,
    .settings-content::-webkit-scrollbar-thumb {
      background: rgba(96, 165, 250, 0.3);
      border-radius: 3px;
    }

    .side-card::-webkit-scrollbar-thumb:hover,
    .settings-content::-webkit-scrollbar-thumb:hover {
      background: rgba(96, 165, 250, 0.5);
    }

    .header {
      grid-area: header;
      background: rgba(5, 7, 17, 0.95);
      border-bottom: 1px solid var(--tile-border);
      padding: 12px 20px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    h1 {
      font-size: 1.4rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin: 0;
      text-align: center;
    }

    .subtitle {
      font-size: 0.85rem;
      color: var(--text-muted);
      text-align: center;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .last-updated {
      font-size: 0.75rem;
      color: var(--accent);
      font-style: italic;
    }

    .main-content {
      grid-area: main;
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 0;
      overflow: hidden;
    }

    /* Tablet and Mobile Responsive */
    @media (max-width: 1024px) {
      .main-content {
        grid-template-columns: 1fr 280px;
      }
    }

    @media (max-width: 900px) {
      .main-content {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }
      
      .side-card {
        order: -1;
        max-height: 40vh;
        overflow-y: auto;
        border-bottom: 1px solid var(--tile-border);
      }
      
      .board-card {
        padding: 12px;
      }
      
      .perspective-wrapper {
        height: min(55vh, 450px);
      }
    }

    @media (max-width: 600px) {
      body {
        grid-template-rows: auto 1fr;
      }
      
      .header {
        padding: 8px 12px;
      }
      
      h1 {
        font-size: 1rem;
      }
      
      .subtitle {
        font-size: 0.7rem;
      }
      
      .footer {
        display: none;
      }
      
      .board-card {
        padding: 8px;
      }
      
      .perspective-wrapper {
        height: min(50vh, 400px);
      }
      
      .side-card {
        padding: 8px;
        max-height: 35vh;
      }
      
      .players-list, .eliminated-list {
        font-size: 0.75rem;
      }
      
      .player-row {
        padding: 4px;
      }
      
      .player-rank {
        font-size: 0.6rem;
        padding: 1px 4px;
        min-width: 20px;
      }
      
      .player-dot {
        width: 10px;
        height: 10px;
      }
      
      .event-log {
        font-size: 0.7rem;
        padding: 5px 6px;
      }
      
      .dice-3d {
        width: 30px;
        height: 30px;
      }
      
      .dice-face {
        width: 30px;
        height: 30px;
        padding: 3px;
      }
      
      .dice-dot {
        width: 5px;
        height: 5px;
      }
      
      .scoreboard-dice-display {
        padding: 6px;
      }
      
      .player-token {
        width: 16px;
        height: 16px;
      }
      
      .player-token-label {
        font-size: 0.35rem;
        padding: 0px 2px;
        top: -6px;
      }
      
      body:not(.dev-mode) .dev-controls {
        display: none;
      }
      
      .connection-card, .winner-card {
        margin: 0 12px;
        padding: 20px;
      }
      
      .winner-trophy {
        font-size: 3.5rem;
      }
      
      .winner-title {
        font-size: 1.8rem;
      }
      
      .winner-name {
        font-size: 1.3rem;
      }
      
      .winner-drops {
        font-size: 1rem;
      }
    }

    @media (max-width: 400px) {
      h1 {
        font-size: 0.9rem;
      }
      
      .subtitle {
        display: none;
      }
      
      .perspective-wrapper {
        height: min(45vh, 350px);
      }
      
      .player-token {
        width: 14px;
        height: 14px;
      }
      
      .player-token-label {
        font-size: 0.3rem;
        padding: 0px 2px;
        top: -5px;
      }
      
      .tile-label {
        font-size: 0.35rem;
      }
    }

    .board-card {
      background: radial-gradient(circle at top left, #111827 0, #020617 55%);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow: hidden;
      height: 100%;
    }

    .board-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .live-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--danger);
      box-shadow: 0 0 8px rgba(248, 113, 113, 0.9);
      margin-right: 4px;
    }

    .live-label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-weight: 600;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #fecaca;
    }

    .board-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: flex-end;
    }

    .control-group {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .control-group label {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .control-group input[type="range"] {
      width: 80px;
    }

    .btn-small {
      font-size: 0.7rem;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      cursor: pointer;
      transition: all 0.2s ease;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .btn-small:hover {
      border-color: var(--accent);
      background: rgba(15, 23, 42, 1);
    }

    .btn-small:active {
      transform: scale(0.95);
    }

    /* Touch-friendly interactive elements */
    @media (max-width: 600px) {
      .btn-small {
        padding: 6px 12px;
        font-size: 0.8rem;
        min-height: 36px;
      }
    }

    .perspective-wrapper {
      position: relative;
      width: 100%;
      height: min(60vh, 520px);
      margin-top: 6px;
      perspective: 1200px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: visible;
    }

    .board-wrapper {
      transform-style: preserve-3d;
      transition: transform 0.2s ease-out;
    }

    .board3d {
      position: relative;
      width: min(460px, 80vw);
      aspect-ratio: 1 / 1;
      background: radial-gradient(
          circle at 30% 0%,
          rgba(56, 189, 248, 0.2),
          transparent 55%
        );
      border-radius: 22px;
      transform: rotateX(55deg) rotateZ(45deg);
      transform-style: preserve-3d;
      box-shadow: 0 30px 80px rgba(0, 0, 0, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.4);
      overflow: visible;
    }

    .board-surface {
      position: absolute;
      inset: 22px;
      background: radial-gradient(circle at top, #111827, #020617);
      border-radius: 18px;
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(31, 41, 55, 0.9);
    }

    .tiles-grid {
      position: absolute;
      inset: 36px;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-template-rows: repeat(7, 1fr);
      gap: 4px;
      transform-style: preserve-3d;
    }

    .tile {
      position: relative;
      background: var(--tile-bg);
      border-radius: 6px;
      border: 1px solid var(--tile-border);
      overflow: hidden;
      box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.7);
    }

    .tile-inner {
      width: 100%;
      height: 100%;
      background-size: cover;
      background-position: center;
      position: relative;
    }

    .tile-label {
      position: absolute;
      left: 3px;
      bottom: 3px;
      right: 3px;
      font-size: 0.45rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-main);
      background: linear-gradient(
        to top,
        rgba(15, 23, 42, 0.9),
        rgba(15, 23, 42, 0.1)
      );
      padding: 2px 4px;
      border-radius: 4px;
      text-align: center;
      backdrop-filter: blur(4px);
    }

    .tile.empty {
      background: transparent;
      border: none;
      box-shadow: none;
    }

    .tokens-layer {
      position: absolute;
      inset: 36px;
      transform-style: preserve-3d;
      inset: 36px;
      z-index: 1000;
    }
    .player-token {
      position: absolute;
      width: 40px;
      height: 40px;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      filter: drop-shadow(0 6px 4px rgba(0, 0, 0, 0.6)) drop-shadow(0 2px 12px rgba(0, 0, 0, 0.4));
      transition: all 0.4s ease-out;
      z-index: 2000;
    }
    
    /* Eliminated player styling */
    .player-token.eliminated {
      filter: grayscale(100%) blur(2px) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8));
      opacity: 0.4;
      position: relative;
    }
    
    .player-token.eliminated::before {
      content: '';
      position: absolute;
      top: -8px;
      right: -8px;
      font-size: 20px;
      background: var(--danger);
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(249, 115, 115, 0.8);
      z-index: 100;
    }
    
    .player-token.eliminated::after {
      content: '';
      position: absolute;
      top: 50%;
      left: -5px;
      right: -5px;
      height: 3px;
      background: var(--danger);
      transform: translateY(-50%) rotate(-15deg);
      box-shadow: 0 0 8px rgba(249, 115, 115, 0.8);
    }

    .player-token[data-player="P1"] {
      background-image: url("assets/pawns/pawn-red.svg");
    }

    .player-token[data-player="P2"] {
      background-image: url("assets/pawns/pawn-green.svg");
    }

    .player-token[data-player="P3"] {
      background-image: url("assets/pawns/pawn-blue.svg");
    }

    .player-token[data-player="P4"] {
      background-image: url("assets/pawns/pawn-yellow.svg");
    }

    .player-token-label {
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.5rem;
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      padding: 1px 4px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      white-space: nowrap;
    }

    .chance-card {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 160px;
      max-width: 50vw;
      transform: translate(-50%, -50%) translateZ(20px);
      background: linear-gradient(135deg, #0f172a, #020617);
      border-radius: 12px;
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.6);
      overflow: hidden;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease-out;
    }

    .chance-card.visible {
      opacity: 1;
      pointer-events: auto;
      animation: popCard 0.3s ease-out;
    }

    @keyframes popCard {
      0% {
        transform: translate(-50%, -50%) translateZ(20px) scale(0.7);
      }
      100% {
        transform: translate(-50%, -50%) translateZ(20px) scale(1);
      }
    }

    .chance-image {
      width: 100%;
      height: 90px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }

    .chance-body {
      padding: 6px 8px 8px;
    }

    .chance-title {
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--accent);
      margin-bottom: 3px;
    }

    .chance-text {
      font-size: 0.6rem;
      color: var(--text-muted);
      line-height: 1.4;
    }

    .side-card {
      background: radial-gradient(circle at top right, #0f172a, #020617);
      padding: 16px;
      border-left: 1px solid rgba(148, 163, 184, 0.12);
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
      height: 100%;
    }

    .section-title {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .pill {
      font-size: 0.65rem;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: var(--accent);
    }

    .players-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.8rem;
    }

    .player-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 5px 6px;
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(31, 41, 55, 0.9);
    }

    .player-main {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .player-rank {
      font-size: 0.65rem;
      font-weight: 700;
      color: var(--accent);
      background: rgba(96, 165, 250, 0.15);
      border: 1px solid rgba(96, 165, 250, 0.4);
      padding: 2px 5px;
      border-radius: 4px;
      min-width: 24px;
      text-align: center;
    }

    .eliminated-rank {
      color: #ef4444;
      background: rgba(239, 68, 68, 0.15);
      border-color: rgba(239, 68, 68, 0.4);
    }

    .player-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid #020617;
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.6);
    }

    .player-name {
      font-weight: 500;
    }

    .player-meta {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .player-pos {
      font-weight: 500;
      font-size: 0.75rem;
    }

    .event-log {
      font-size: 0.76rem;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px dashed rgba(148, 163, 184, 0.5);
      padding: 6px 8px;
      color: var(--text-muted);
      min-height: 36px;
    }

    .event-highlight {
      color: var(--accent);
      font-weight: 500;
    }

    .muted {
      color: var(--text-muted);
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.72rem;
      color: var(--text-muted);
    }

    .badge-green {
      color: var(--success);
    }

    .badge-red {
      color: var(--danger);
    }

    .footer-note {
      margin-top: 6px;
      font-size: 0.7rem;
      color: var(--text-muted);
      text-align: right;
    }

    .footer {
      grid-area: footer;
      background: rgba(5, 7, 17, 0.95);
      border-top: 1px solid var(--tile-border);
      padding: 8px 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      min-height: 40px;
    }

    /* Settings  (Sidebar) */
    .settings-panel {
      position: fixed;
      right: 0;
      top: 0;
      height: 100vh;
      width: min(340px, 86vw);
      background: rgba(2, 6, 23, 0.96);
      border-left: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow: -10px 0 30px rgba(0, 0, 0, 0.5);
      z-index: 2800;
      backdrop-filter: blur(6px);
      transform: translateX(0);
      transition: transform 0.3s ease-out;
    }

    .settings-panel.hidden {
      transform: translateX(100%);
    }

    .settings-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2700;
      opacity: 1;
      transition: opacity 0.3s ease-out;
    }

    .settings-backdrop.hidden {
      opacity: 0;
      pointer-events: none;
    }

    @media (max-width: 600px) {
      .settings-panel {
        width: 100vw;
      }
    }

    .settings-content {
      padding: 16px;
      color: var(--text-main);
      height: 100%;
      overflow-y: auto;
    }

    .settings-title {
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--tile-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .settings-section {
      margin-bottom: 20px;
      padding: 12px;
      background: rgba(15, 23, 42, 0.5);
      border-radius: 8px;
      border: 1px solid var(--tile-border);
    }

    .settings-subsection-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 10px;
      padding-bottom: 6px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
    }

    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin: 8px 0;
    }

    .row label {
      font-size: 0.85rem;
      color: var(--text-muted);
      min-width: 60px;
      flex: 1;
    }

    .row span:last-child {
      min-width: 40px;
      text-align: right;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .row input[type="range"] {
      flex: 1;
    }

    .row input[type="number"] {
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--tile-border);
      color: var(--text-main);
      padding: 4px 6px;
      border-radius: 4px;
    }

    .board-status {
      font-size: 0.75rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* Eliminated Players */
    .eliminated-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.75rem;
      min-height: 30px;
    }

    .eliminated-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      background: rgba(127, 29, 29, 0.2);
      border-radius: 6px;
      border: 1px solid rgba(220, 38, 38, 0.3);
      opacity: 0.7;
    }

    .eliminated-token {
      width: 16px;
      height: 16px;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      filter: grayscale(100%) brightness(0.6);
    }

    /* Winner Celebration Overlay */
    .winner-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.5s ease-out;
    }

    .winner-overlay.hidden {
      display: none;
    }

    .winner-card {
      background: linear-gradient(135deg, #0f172a, #1e293b);
      border: 3px solid var(--accent);
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      position: relative;
      animation: bounceIn 0.6s ease-out;
    }

    .winner-trophy {
      font-size: 5rem;
      animation: bounce 1s infinite;
    }

    .winner-title {
      font-size: 2.5rem;
      font-weight: 800;
      color: var(--accent);
      letter-spacing: 0.2em;
      margin: 10px 0;
      text-shadow: 0 0 20px rgba(96, 165, 250, 0.5);
    }

    .winner-name {
      font-size: 1.8rem;
      font-weight: 600;
      color: var(--text-main);
      margin: 10px 0;
    }

    .winner-drops {
      font-size: 1.3rem;
      color: var(--accent);
      font-weight: 500;
    }

    .winner-confetti {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background: var(--accent);
      top: -10px;
      animation: fall 3s linear infinite;
    }

    .confetti:nth-child(1) { left: 10%; animation-delay: 0s; background: #60a5fa; }
    .confetti:nth-child(2) { left: 25%; animation-delay: 0.3s; background: #34d399; }
    .confetti:nth-child(3) { left: 40%; animation-delay: 0.6s; background: #fbbf24; }
    .confetti:nth-child(4) { left: 55%; animation-delay: 0.9s; background: #f87171; }
    .confetti:nth-child(5) { left: 70%; animation-delay: 1.2s; background: #a78bfa; }
    .confetti:nth-child(6) { left: 85%; animation-delay: 1.5s; background: #fb923c; }
    .confetti:nth-child(7) { left: 20%; animation-delay: 0.5s; background: #60a5fa; }
    .confetti:nth-child(8) { left: 75%; animation-delay: 1s; background: #34d399; }

    @keyframes fall {
      to { top: 100%; transform: rotate(360deg); }
    }

    @keyframes bounceIn {
      0% { transform: scale(0.3) rotate(-10deg); opacity: 0; }
      50% { transform: scale(1.05) rotate(2deg); }
      100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-20px); }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* Small Screen Disclaimer */
    .small-screen-disclaimer {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.92);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 15000;
      padding: 20px;
      animation: fadeIn 0.4s ease-out;
    }

    .small-screen-disclaimer.hidden {
      display: none;
    }

    .disclaimer-content {
      background: linear-gradient(135deg, #0f172a, #1e293b);
      border: 2px solid var(--accent);
      border-radius: 16px;
      padding: 30px 24px;
      text-align: center;
      max-width: 400px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      animation: bounceIn 0.5s ease-out;
    }

    .disclaimer-icon {
      font-size: 3rem;
      margin-bottom: 12px;
    }

    .disclaimer-title {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 12px;
      letter-spacing: 0.05em;
    }

    .disclaimer-text {
      font-size: 0.9rem;
      color: var(--text-muted);
      line-height: 1.6;
      margin-bottom: 20px;
    }

    @media (max-width: 400px) {
      .disclaimer-content {
        padding: 24px 18px;
      }

      .disclaimer-icon {
        font-size: 2.5rem;
      }

      .disclaimer-title {
        font-size: 1.1rem;
      }

      .disclaimer-text {
        font-size: 0.85rem;
      }
    }
  </style>
</head>
<body>
  
  <!-- Small Screen Disclaimer -->
  <div id="smallScreenDisclaimer" class="small-screen-disclaimer hidden">
    <div class="disclaimer-content">
      <div class="disclaimer-icon">=ƒô¦</div>
      <div class="disclaimer-title">Best Viewed on Large Screens</div>
      <div class="disclaimer-text">
        This live board is designed for TV and large screens for an immersive gaming experience. 
        For the best experience, please use a larger display (tablet, laptop, or TV).
      </div>
      <button id="dismissDisclaimer" class="btn-small">Continue Anyway</button>
    </div>
  </div>
  
  <div id="tutorialOverlay" class="tutorial-overlay hidden">
    <div class="tutorial-card">
      <div class="tutorial-title">How to Play</div>
      <ol class="tutorial-steps">
        <li>Roll the dice.</li>
        <li>Watch your pawn move.</li>
        <li>Read the tile effect.</li>
      </ol>
      <button id="closeTutorial" class="btn-small">Got it</button>
    </div>
  </div>

  <!-- Connection Popup -->
  <div id="connectionOverlay" class="connection-overlay hidden">
    <div class="connection-card">
      <div class="connection-title">=ƒÄ« Connect LastDrop Controller</div>
      <div class="connection-content">
        <div class="connection-status">
          <div class="status-indicator" id="connectionIndicator">
            <div class="status-dot"></div>
            <span id="connectionText">Waiting for controller...</span>
          </div>
        </div>
        <div class="connection-instructions">
          <p>1. Open LastDrop app on your phone</p>
          <p>2. Start a game session</p>
          <p>3. Roll dice to connect automatically</p>
        </div>
        <div class="connection-actions">
          <button id="skipConnection" class="btn-small">Skip (Demo Mode)</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Reconnection Overlay -->
  <div id="reconnectionOverlay" class="connection-overlay hidden">
    <div class="connection-card">
      <div class="connection-title">=ƒöä Reconnecting...</div>
      <div class="connection-content">
        <div class="connection-status">
          <div class="status-indicator">
            <div class="spinner"></div>
            <span id="reconnectionText">Attempting to reconnect...</span>
          </div>
        </div>
        <div class="reconnection-info" id="reconnectionInfo">
          <p>Retry attempt: <strong id="retryAttempt">1</strong>/5</p>
          <p>Next retry in: <strong id="retryDelay">2</strong>s</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Welcome Screen (Demo Mode) -->
  <div id="welcomeOverlay" class="connection-overlay">
    <div class="connection-card" style="max-width: 600px; max-height: 90vh; overflow-y: auto;">
      <div class="connection-title">&#128167; Welcome to Last Drop Demo!</div>
      <div class="connection-content" style="text-align: left;">
        <div style="background: rgba(15,23,42,0.5); padding: 16px; border-radius: 8px; margin-bottom: 16px;">
          <h3 style="color: var(--accent); margin-top: 0; font-size: 1.1rem;">&#127919; Game Objective</h3>
          <p style="margin: 8px 0; font-size: 0.9rem; line-height: 1.6;">
            Be the last player standing with water drops! Collect drops by landing on positive tiles, 
            avoid negative tiles, and survive till the end.
          </p>
        </div>
        
        <div style="background: rgba(15,23,42,0.5); padding: 16px; border-radius: 8px; margin-bottom: 16px;">
          <h3 style="color: var(--accent); margin-top: 0; font-size: 1.1rem;">&#127922; How to Play</h3>
          <ul style="margin: 8px 0; padding-left: 20px; font-size: 0.85rem; line-height: 1.8;">
            <li><strong>Roll the dice</strong> - Move forward based on dice value</li>
            <li><strong>Tile effects</strong> - Gain or lose water drops depending on where you land</li>
            <li><strong>Chance cards</strong> - Land on special tiles to draw random events</li>
            <li><strong>Complete laps</strong> - Pass START to earn +5 bonus drops</li>
            <li><strong>Elimination</strong> - Players with 0 drops are out of the game</li>
          </ul>
        </div>
        
        <div style="background: rgba(15,23,42,0.5); padding: 16px; border-radius: 8px; margin-bottom: 20px;">
          <h3 style="color: var(--accent); margin-top: 0; font-size: 1.1rem;">&#10024; Demo Features</h3>
          <p style="margin: 8px 0; font-size: 0.85rem; line-height: 1.6;">
            Watch 4 AI players compete automatically. See dice rolls, token movement, 
            chance cards, and real-time scoring in action!
          </p>
        </div>
        
        <div style="text-align: center;">
          <button id="startDemoBtn" class="btn-small" style="font-size: 1rem; padding: 12px 32px; background: linear-gradient(135deg, var(--accent), #60a5fa); border: none; cursor: pointer;">
            &#127918; Start Demo Game
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Header -->
  <header class="header">
    <h1>LAST DROP &#128167; DEMO MODE</h1>
    <div class="subtitle">
      Play the demo version in your browser - <a href="live.html" style="color: var(--accent); text-decoration: underline;">Switch to Live Mode</a>
      <span id="sessionInfo" class="last-updated" style="color: #60a5fa;"></span>
      <span id="lastUpdated" class="last-updated"></span>
    </div>
  </header>

  <!-- Main Content Area -->
  <main class="main-content">
    <!-- Board Section -->
    <section class="board-card">
      <div class="board-header">
        <div class="live-label">
          <span class="live-dot"></span>
          Live
        </div>
        <span class="board-status">
          Connection: <span id="connStatus" class="badge-red">OFFLINE</span>
        </span>
      </div>

      <div class="perspective-wrapper">
        <div id="boardWrapper" class="board-wrapper">
          <div id="board3d" class="board3d">
            <div class="board-surface"></div>
            <div class="tiles-grid" id="tilesGrid"></div>
            <div class="tokens-layer" id="tokensLayer"></div>
            
            <div id="chanceCard" class="chance-card">
              <div id="chanceImage" class="chance-image"></div>
              <div class="chance-body">
                <div id="chanceTitle" class="chance-title">Chance Card</div>
                <div id="chanceText" class="chance-text">Awaiting event...ª</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Scoreboard Sidebar -->
    <aside class="side-card">
      <div class="section-title">
        Players
        <span class="pill">Synced from ESP32</span>
      </div>
      <div id="playersList" class="players-list"></div>

      <div class="section-title">
        Last Event
        <span class="pill">Dice / Tile / Card</span>
      </div>

      <!-- Dice Display for Scoreboard -->
      <div id="scoreboardDiceDisplay" class="scoreboard-dice-display">
        <div id="dicePlayerName" class="dice-player-name">Player 1 rolling dice...</div>
        <div class="dice-3d-container">
          <div id="scoreboardDice1" class="dice-3d">
            <div class="dice-face dice-front" data-value="1">
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
            </div>
            <div class="dice-face dice-back" data-value="6">
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
            </div>
            <div class="dice-face dice-right" data-value="3">
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
            </div>
            <div class="dice-face dice-left" data-value="4">
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
            </div>
            <div class="dice-face dice-top" data-value="5">
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
            </div>
            <div class="dice-face dice-bottom" data-value="2">
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
            </div>
          </div>
          <div id="scoreboardDice2" class="dice-3d">
            <div class="dice-face dice-front" data-value="1">
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
            </div>
            <div class="dice-face dice-back" data-value="6">
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
            </div>
            <div class="dice-face dice-right" data-value="3">
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
            </div>
            <div class="dice-face dice-left" data-value="4">
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
            </div>
            <div class="dice-face dice-top" data-value="5">
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
            </div>
            <div class="dice-face dice-bottom" data-value="2">
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
              <span class="dice-dot"></span>
            </div>
          </div>
        </div>
      </div>

      <div id="eventLog" class="event-log">Waiting for first drop...ª</div>

      <div class="section-title" style="margin-top: 12px;">
        Eliminated
        <span class="pill" id="eliminatedCount">0</span>
      </div>
      <div id="eliminatedList" class="eliminated-list"></div>

      <div class="status-row">
        <span>Connection: <span id="connStatus" class="badge-red">OFFLINE</span></span>
        <span>Mode: <span id="modeStatus" class="badge-green">DEMO</span></span>
      </div>

      <div class="footer-note">
        ESP32 GåÆ Android GåÆ Server GåÆ Live GÇö visual only, rules stay on hardware.
      </div>
    </aside>
  </main>

  <!-- Winner Celebration Overlay -->
  <div id="winnerOverlay" class="winner-overlay hidden">
    <div class="winner-card">
      <div class="winner-trophy">=ƒÅå</div>
      <div class="winner-title">WINNER!</div>
      <div id="winnerName" class="winner-name">Player 1</div>
      <div id="winnerDrops" class="winner-drops">=ƒÆº 15 drops</div>
      <div class="winner-confetti">
        <div class="confetti"></div>
        <div class="confetti"></div>
        <div class="confetti"></div>
        <div class="confetti"></div>
        <div class="confetti"></div>
        <div class="confetti"></div>
        <div class="confetti"></div>
        <div class="confetti"></div>
      </div>
    </div>
  </div>

  <!-- Footer -->
  <footer class="footer">
    <button id="settingsBtn" class="btn-small" type="button"> Settings</button>
  </footer>

  <!-- Settings rop -->
  <div id="settingsBackdrop" class="settings-backdrop hidden"></div>

  <!-- Settings  (Sidebar) -->
  <div id="settingsPanel" class="settings-panel hidden">
    <div class="settings-content">
      <div class="settings-title">
        <span> Settings</span>
        <button id="closeSettings" class="btn-small" type="button"> Close</button>
      </div>
      
      <div class="settings-section">
        <div class="row">
          <label>View</label>
          <button id="viewToggle" class="btn-small" type="button">Toggle</button>
          <span id="viewStatus">Top</span>
        </div>
        <div class="row">
          <label for="zoomRange">Zoom</label>
          <input id="zoomRange" type="range" min="70" max="130" value="100" />
        </div>
        <div class="row">
          <label for="rotateXRange">Tilt X</label>
          <input id="rotateXRange" type="range" min="0" max="90" value="55" />
        </div>
        <div class="row">
          <label for="rotateYRange">Tilt Y</label>
          <input id="rotateYRange" type="range" min="-45" max="45" value="0" />
        </div>
        <div class="row">
          <label for="rotateRange">Rotate</label>
          <input id="rotateRange" type="range" min="-30" max="30" value="45" />
        </div>
      </div>

      <div class="settings-section">
        <div class="row">
          <label>Kid Mode</label>
          <button id="kidToggle" class="btn-small" type="button">Toggle</button>
          <span id="kidStatus">OFF</span>
        </div>
        <div class="row">
          <label>Dev Mode</label>
          <button id="devToggle" class="btn-small" type="button">Toggle</button>
          <span id="devStatus">ON</span>
        </div>
      </div>

      <div class="settings-section" id="devControls" class="dev-controls">
        <div class="row">
          <label for="offsetXRange">Coin X</label>
          <input id="offsetXRange" type="number" min="-50" max="50" value="-12" style="width:60px" />
          <span id="offsetXValue">-12</span>
        </div>
        <div class="row">
          <label for="offsetYRange">Coin Y</label>
          <input id="offsetYRange" type="number" min="-50" max="50" value="0" style="width:60px" />
          <span id="offsetYValue">0</span>
        </div>
        <div class="row">
          <button id="applyCoinOffset" class="btn-small" type="button">Apply Offset</button>
        </div>
      </div>

      <div class="settings-section">
        <div class="row">
          <label>Demo Mode</label>
          <button id="demoToggle" class="btn-small" type="button">Toggle</button>
          <span id="demoStatus">OFF</span>
        </div>
        <div class="row">
          <button id="helpBtn" class="btn-small" type="button">Show Tutorial</button>
        </div>
      </div>

      <div class="settings-section">
        <div class="settings-subsection-title"> Audio Controls</div>
        <div class="row">
          <label>Master Audio</label>
          <button id="audioToggle" class="btn-small" type="button">Toggle</button>
          <span id="audioStatus">ON</span>
        </div>
        <div class="row">
          <label for="bgMusicVolume">Background Music</label>
          <input id="bgMusicVolume" type="range" min="0" max="100" value="30" />
          <span id="bgMusicValue">30%</span>
        </div>
        <div class="row">
          <label for="diceVolume">Dice Roll</label>
          <input id="diceVolume" type="range" min="0" max="100" value="50" />
          <span id="diceValue">50%</span>
        </div>
        <div class="row">
          <label for="moveVolume">Coin Movement</label>
          <input id="moveVolume" type="range" min="0" max="100" value="40" />
          <span id="moveValue">40%</span>
        </div>
        <div class="row">
          <label for="chanceVolume">Chance Card</label>
          <input id="chanceVolume" type="range" min="0" max="100" value="50" />
          <span id="chanceValue">50%</span>
        </div>
        <div class="row">
          <label for="tileVolume">Tile Landing</label>
          <input id="tileVolume" type="range" min="0" max="100" value="40" />
          <span id="tileValue">40%</span>
        </div>
        <div class="row">
          <label for="eliminatedVolume">Elimination</label>
          <input id="eliminatedVolume" type="range" min="0" max="100" value="60" />
          <span id="eliminatedValue">60%</span>
        </div>
        <div class="row">
          <label for="winnerVolume">Winner</label>
          <input id="winnerVolume" type="range" min="0" max="100" value="70" />
          <span id="winnerValue">70%</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Parse URL parameters for session-specific viewing
    const urlParams = new URLSearchParams(window.location.search);
    const sessionParam = urlParams.get('session');  // Format: "LASTDROP-0001_uuid"
    const boardIdParam = urlParams.get('board');     // Alternative: just board ID
    
    // Extract boardId and sessionId from URL
    let activeBoardId = null;
    let activeSessionId = null;
    
    if (sessionParam) {
      const parts = sessionParam.split('_');
      activeBoardId = parts[0];
      activeSessionId = parts.length > 1 ? parts[1] : null;
    } else if (boardIdParam) {
      activeBoardId = boardIdParam;
    }
    
    // Build API URL with session parameters
    let LIVE_STATE_URL = "/api/live_state.php?key=ABC123";
    if (activeBoardId) {
      LIVE_STATE_URL += `&boardId=${encodeURIComponent(activeBoardId)}`;
    }
    if (activeSessionId) {
      LIVE_STATE_URL += `&sessionId=${encodeURIComponent(activeSessionId)}`;
    }
    
    console.log('[live] Session parameters:', { boardId: activeBoardId, sessionId: activeSessionId });
    console.log('[live] API URL:', LIVE_STATE_URL);
    
    const tileNames = ["START","Tile 2","Tile 3","Tile 4","Tile 5","Tile 6","Tile 7","Tile 8","Tile 9","Tile 10","Tile 11","Tile 12","Tile 13","Tile 14","Tile 15","Tile 16","Tile 17","Tile 18","Tile 19","Tile 20"];
    let demoMode = false;

    // Audio System
    const audioEnabled = { value: true };
    const audioVolumes = {
      bgMusic: 0.3,
      dice: 0.5,
      move: 0.4,
      chance: 0.5,
      tile: 0.4,
      eliminated: 0.6,
      winner: 0.7
    };

    // Audio players (using Web Audio API compatible approach)
    const audioPlayers = {};
    
    function playSound(type) {
      if (!audioEnabled.value) return;
      
      // For now, we'll use a simple beep generator as placeholder
      // In production, you'd load actual audio files
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = ctx.createOscillator();
      const gainNode = ctx.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);
      
      // Different frequencies for different sounds
      const frequencies = {
        dice: 440,
        move: 523,
        chance: 659,
        tile: 392,
        eliminated: 293,
        winner: 880
      };
      
      oscillator.frequency.value = frequencies[type] || 440;
      oscillator.type = 'sine';
      
      const volume = audioVolumes[type] || 0.5;
      gainNode.gain.setValueAtTime(volume, ctx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
      
      oscillator.start(ctx.currentTime);
      oscillator.stop(ctx.currentTime + 0.2);
    }

    // Background music loop
    let bgMusicInterval;
    function startBackgroundMusic() {
      if (bgMusicInterval) return;
      if (!audioEnabled.value) return;
      // Placeholder - in production, use actual audio file
      // bgMusicInterval = setInterval(() => {}, 30000);
    }

    function stopBackgroundMusic() {
      if (bgMusicInterval) {
        clearInterval(bgMusicInterval);
        bgMusicInterval = null;
      }
    }

    const boardWrapper = document.getElementById("boardWrapper");
    const board3d = document.getElementById("board3d");
    const tokensLayer = document.getElementById("tokensLayer");
    const tilesGrid = document.getElementById("tilesGrid");
    const zoomRange = document.getElementById("zoomRange");
    const rotateRange = document.getElementById("rotateRange");
    const rotateXRange = document.getElementById("rotateXRange");
    const rotateYRange = document.getElementById("rotateYRange");
    const playersList = document.getElementById("playersList");
    const eliminatedList = document.getElementById("eliminatedList");
    const eliminatedCount = document.getElementById("eliminatedCount");
    const winnerOverlay = document.getElementById("winnerOverlay");
    const winnerName = document.getElementById("winnerName");
    const winnerDrops = document.getElementById("winnerDrops");
    const sessionInfoEl = document.getElementById("sessionInfo");
    
    // Display session info in header if present
    if (activeBoardId || activeSessionId) {
      let sessionText = "Viewing: ";
      if (activeBoardId) {
        sessionText += `Board ${activeBoardId}`;
      }
      if (activeSessionId) {
        const shortSession = activeSessionId.substring(0, 8);
        sessionText += ` (Session: ${shortSession}...)`;
      }
      sessionInfoEl.textContent = sessionText;
      console.log('[live] Session info displayed:', sessionText);
    }
    
    // Track previously eliminated players to detect new eliminations
    let previouslyEliminatedIds = new Set();
    
    // Track last event to detect new dice rolls
    let lastProcessedEvent = null;
    let currentDiceColor = "#60a5fa"; // Default blue, updated from API
    // Guard to prevent token moves while dice animation plays
    let isDiceAnimationPlaying = false;
    // Store the latest polled state while animation is playing (only keep newest)
    let queuedLiveState = null;
    // Timer to delay token movement after receiving dice roll from API
    let tokenMoveTimer = null;
    
    const eventLog = document.getElementById("eventLog");
    const connStatus = document.getElementById("connStatus");
    const modeStatus = document.getElementById("modeStatus");
    const demoToggle = document.getElementById("demoToggle");
    const viewToggle = document.getElementById("viewToggle");
    const offsetXRange = document.getElementById("offsetXRange");
    const offsetYRange = document.getElementById("offsetYRange");
    const viewStatus = document.getElementById("viewStatus");
    let is3DView = false;
    const demoStatus = document.getElementById("demoStatus");
    const chanceCard = document.getElementById("chanceCard");
    const chanceImage = document.getElementById("chanceImage");
    const chanceTitle = document.getElementById("chanceTitle");
    const chanceText = document.getElementById("chanceText");

    // Connection popup elements - moved inside load event to ensure DOM is ready
    let connectionOverlay, connectionIndicator, connectionText, skipConnection;
    let reconnectionOverlay, reconnectionText, retryAttemptEl, retryDelayEl, reconnectionInfo;
    let loadingOverlay;
    let firstFetchComplete = false;
    let lastUpdatedEl;

    // Dice elements
    let diceDisplay, dice1El, dice2El;
    let scoreboardDiceDisplay, scoreboardDice1, scoreboardDice2, dicePlayerName;

    const tileCenters = {};
    const tokensByPlayerId = {};
    let lastChanceTimeout = null;
    let connectionEstablished = false;

    function initTiles() {
      const grid = [1,2,3,4,5,6, 20,0,0,0,0,7, 19,0,0,0,0,8, 18,0,0,0,0,9, 17,0,0,0,0,10, 16,15,14,13,12,11];
      grid.forEach((tileNum,idx) => {
        const tile = document.createElement("div");
        if (tileNum === 0) {
          tile.className = "tile empty";
        } else {
          tile.className = "tile";
          tile.dataset.tile = tileNum;
          const inner = document.createElement("div");
          inner.className = "tile-inner";
          inner.style.backgroundImage = `url('/assets/tiles/tile-${tileNum}.jpg')`;
          const label = document.createElement("div");
          label.className = "tile-label";
          label.textContent = tileNames[tileNum-1] || ("Tile "+tileNum);
          inner.appendChild(label);
          tile.appendChild(inner);
        }
        tilesGrid.appendChild(tile);
      });
    }

    function computeTileCenters() {
      const tokensLayerRect = tokensLayer.getBoundingClientRect();
      tilesGrid.querySelectorAll(".tile[data-tile]").forEach(tile => {
        const rect = tile.getBoundingClientRect();
        const tileIndex = tile.dataset.tile;
        tileCenters[tileIndex] = {
          x: rect.left - tokensLayerRect.left + rect.width / 2,
          y: rect.top - tokensLayerRect.top + rect.height / 2
        };
      });
    }

    window.addEventListener("resize", () => {
      computeTileCenters();
      positionExistingTokens();
    });

    function updateBoardTransform() {
      const zoom = parseInt(zoomRange.value, 10) / 100;
      if (!is3DView) {
        boardWrapper.style.transform = `scale(${zoom})`;
      } else {
        // 3D view - use slider values
        const rotX = parseInt(rotateXRange.value, 10);
        const rotY = parseInt(rotateYRange.value, 10);
        const rotZ = parseInt(rotateRange.value, 10);
        boardWrapper.style.transform = `scale(${zoom}) rotateX(${rotX}deg) rotateY(${rotY}deg) rotateZ(${rotZ}deg)`;
      }
    }

    zoomRange.addEventListener("input", updateBoardTransform);
    rotateRange.addEventListener("input", updateBoardTransform);
    rotateXRange.addEventListener("input", updateBoardTransform);
    rotateYRange.addEventListener("input", updateBoardTransform);
    
    function updateCoinOffsetDisplay() {
      document.getElementById("offsetXValue").textContent = offsetXRange.value;
      document.getElementById("offsetYValue").textContent = offsetYRange.value;
    }
    
    offsetXRange.addEventListener("input", updateCoinOffsetDisplay);
    offsetYRange.addEventListener("input", updateCoinOffsetDisplay);
    
    document.getElementById("applyCoinOffset").addEventListener("click", () => {
      positionExistingTokens();
    });

    viewToggle.addEventListener("click", () => {
      is3DView = !is3DView;
      viewStatus.textContent = is3DView ? "3D" : "Top";
      if (is3DView) {
        // 3D view - restore slider values
        updateBoardTransform();
        board3d.style.transform = "";
      } else {
        // Top view - completely flat
        const zoom = parseInt(zoomRange.value, 10) / 100;
        boardWrapper.style.transform = `scale(${zoom})`;
        board3d.style.transform = "rotateX(0deg) rotateY(0deg) rotateZ(0deg)";
      }
      // Recalculate tile centers and reposition tokens after view change
      setTimeout(() => {
        computeTileCenters();
        positionExistingTokens();
      }, 100);
    });

    demoToggle.addEventListener("click", () => {
      demoMode = !demoMode;
      demoStatus.textContent = demoMode ? "ON" : "OFF";
      modeStatus.textContent = demoMode ? "DEMO" : "LIVE";
      if (!demoMode) fetchAndUpdate();
    });

    // Audio controls
    const audioToggle = document.getElementById("audioToggle");
    const audioStatus = document.getElementById("audioStatus");
    const bgMusicVolume = document.getElementById("bgMusicVolume");
    const diceVolume = document.getElementById("diceVolume");
    const moveVolume = document.getElementById("moveVolume");
    const chanceVolume = document.getElementById("chanceVolume");
    const tileVolume = document.getElementById("tileVolume");
    const eliminatedVolume = document.getElementById("eliminatedVolume");
    const winnerVolume = document.getElementById("winnerVolume");

    audioToggle?.addEventListener("click", () => {
      audioEnabled.value = !audioEnabled.value;
      audioStatus.textContent = audioEnabled.value ? "ON" : "OFF";
      if (audioEnabled.value) {
        startBackgroundMusic();
      } else {
        stopBackgroundMusic();
      }
    });

    bgMusicVolume?.addEventListener("input", (e) => {
      const val = parseInt(e.target.value);
      audioVolumes.bgMusic = val / 100;
      document.getElementById("bgMusicValue").textContent = `${val}%`;
    });

    diceVolume?.addEventListener("input", (e) => {
      const val = parseInt(e.target.value);
      audioVolumes.dice = val / 100;
      document.getElementById("diceValue").textContent = `${val}%`;
    });

    moveVolume?.addEventListener("input", (e) => {
      const val = parseInt(e.target.value);
      audioVolumes.move = val / 100;
      document.getElementById("moveValue").textContent = `${val}%`;
    });

    chanceVolume?.addEventListener("input", (e) => {
      const val = parseInt(e.target.value);
      audioVolumes.chance = val / 100;
      document.getElementById("chanceValue").textContent = `${val}%`;
    });

    tileVolume?.addEventListener("input", (e) => {
      const val = parseInt(e.target.value);
      audioVolumes.tile = val / 100;
      document.getElementById("tileValue").textContent = `${val}%`;
    });

    eliminatedVolume?.addEventListener("input", (e) => {
      const val = parseInt(e.target.value);
      audioVolumes.eliminated = val / 100;
      document.getElementById("eliminatedValue").textContent = `${val}%`;
    });

    winnerVolume?.addEventListener("input", (e) => {
      const val = parseInt(e.target.value);
      audioVolumes.winner = val / 100;
      document.getElementById("winnerValue").textContent = `${val}%`;
    });

    function ensureTokenForPlayer(player) {
      const existingToken = tokensByPlayerId[player.id];
      
      // If token exists, update its color in case it changed
      if (existingToken) {
        const color = player.color || 'red';
        existingToken.style.backgroundImage = `url("assets/pawns/pawn-${color}.svg")`;
        return existingToken;
      }
      
      // Create new token
      const token = document.createElement("div");
      token.className = "player-token";
      token.dataset.player = player.id;

      // Set token color from player object
      const color = player.color || 'red';
      token.style.backgroundImage = `url("assets/pawns/pawn-${color}.svg")`;

      const label = document.createElement("div");
      label.className = "player-token-label";
      label.textContent = player.name || player.id;
      token.appendChild(label);
      tokensLayer.appendChild(token);
      tokensByPlayerId[player.id] = token;
      return token;
    }
    function positionToken(playerId, tileIndex, offsetIndex, animate = false, fromTile = null) {
      const token = tokensByPlayerId[playerId];
      if (!token) return;

      // Prevent immediate repositioning while a dice animation is playing.
      // If the client is animating dice and someone requests a non-animated
      // move to a different tile, ignore it GÇö the queued state will be
      // applied after the dice animation completes.
      if (isDiceAnimationPlaying && !animate) {
        const currentIdx = (token.dataset.tileIndex !== undefined && token.dataset.tileIndex !== '') ? parseInt(token.dataset.tileIndex) : null;
        if (currentIdx !== null && currentIdx !== tileIndex) {
          console.debug('[live] positionToken deferred due to dice animation', playerId, 'from', currentIdx, 'to', tileIndex);
          return;
        }
      }

      // Find the target tile element
      const tileElem = tilesGrid.querySelector(`.tile[data-tile="${tileIndex}"]`);
      if (!tileElem) return;

      // If animating, calculate path and animate
      if (animate && fromTile !== null && fromTile !== tileIndex) {
        animateTokenWalk(playerId, fromTile, tileIndex, offsetIndex);
        return;
      }

      // Immediate positioning (no animation)
      if (token.parentElement !== tileElem) tileElem.appendChild(token);

      // Compute per-player offsets from spinner values (arranged 2x2 around base)
      const baseOffsetX = parseInt(offsetXRange.value, 10) || 0;
      const baseOffsetY = parseInt(offsetYRange.value, 10) || 0;
      const offsets = [
        { dx: baseOffsetX - 8, dy: baseOffsetY - 8 },
        { dx: baseOffsetX + 8, dy: baseOffsetY - 8 },
        { dx: baseOffsetX - 8, dy: baseOffsetY + 8 },
        { dx: baseOffsetX + 8, dy: baseOffsetY + 8 }
      ];
      const off = offsets[offsetIndex % 4] || { dx: 0, dy: 0 };

      // Center token within tile and apply offsets (relative to tile)
      token.style.left = `calc(50% + ${off.dx}px)`;
      token.style.top = `calc(50% + ${off.dy}px)`;
      token.style.transform = is3DView
        ? "translate(-50%, -50%) translateZ(20px)"
        : "translate(-50%, -50%)";

      // Update label to show tile number
      const label = token.querySelector(".player-token-label");
      if (label) label.textContent = `Tile ${tileIndex}`;
    }

    // Animate token walking from one tile to another
    function animateTokenWalk(playerId, fromTileIndex, toTileIndex, offsetIndex, onComplete) {
      const token = tokensByPlayerId[playerId];
      if (!token) return;

      console.debug('[live] animateTokenWalk START', playerId, 'from', fromTileIndex, 'to', toTileIndex, 'offset', offsetIndex);

      // Calculate path (tiles to walk through)
      const path = calculateTilePath(fromTileIndex, toTileIndex);
      if (path.length === 0) return;

      let currentStep = 0;
      const stepDuration = 600; // ms per tile (slower for visibility)

      function walkNextStep() {
        if (currentStep >= path.length) {
          // Animation complete - position at final tile
          positionToken(playerId, toTileIndex, offsetIndex, false);
          playSound('tile'); // Play tile landing sound
          if (typeof onComplete === 'function') {
            try { onComplete(); } catch (err) { console.error(err); }
          }
          console.debug('[live] animateTokenWalk END', playerId, 'arrived', toTileIndex);
          return;
        }

        const currentTile = path[currentStep];
        const tileElem = tilesGrid.querySelector(`.tile[data-tile="${currentTile}"]`);
        
        if (tileElem && token.parentElement !== tileElem) {
          tileElem.appendChild(token);
        }

        // Play movement sound for each step
        if (currentStep > 0) playSound('move');

        // Apply position with transition
        const baseOffsetX = parseInt(offsetXRange.value, 10) || 0;
        const baseOffsetY = parseInt(offsetYRange.value, 10) || 0;
        const offsets = [
          { dx: baseOffsetX - 8, dy: baseOffsetY - 8 },
          { dx: baseOffsetX + 8, dy: baseOffsetY - 8 },
          { dx: baseOffsetX - 8, dy: baseOffsetY + 8 },
          { dx: baseOffsetX + 8, dy: baseOffsetY + 8 }
        ];
        const off = offsets[offsetIndex % 4] || { dx: 0, dy: 0 };

        token.style.transition = `all ${stepDuration}ms ease-in-out`;
        token.style.left = `calc(50% + ${off.dx}px)`;
        token.style.top = `calc(50% + ${off.dy}px)`;

        currentStep++;
        setTimeout(walkNextStep, stepDuration);
      }

      walkNextStep();
    }

    // Calculate the path of tiles from start to end
    function calculateTilePath(fromTile, toTile) {
      const boardSequence = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];
      
      const fromIndex = boardSequence.indexOf(fromTile);
      const toIndex = boardSequence.indexOf(toTile);
      
      if (fromIndex === -1 || toIndex === -1) return [];
      
      const path = [];
      if (fromIndex < toIndex) {
        // Moving forward
        for (let i = fromIndex + 1; i <= toIndex; i++) {
          path.push(boardSequence[i]);
        }
      } else {
        // Moving backward or wrapping around
        for (let i = fromIndex + 1; i < boardSequence.length; i++) {
          path.push(boardSequence[i]);
        }
        for (let i = 0; i <= toIndex; i++) {
          path.push(boardSequence[i]);
        }
      }
      
      return path;
    }
    function positionExistingTokens() {
      Object.values(tokensByPlayerId).forEach((token, index) => {
        const tileIndex = token.dataset.tileIndex;
        if (tileIndex) positionToken(token.dataset.player, tileIndex, index);
      });
    }

    function updateUIFromState(state) {
      if (!state) return;
      playersList.innerHTML = "";
      eliminatedList.innerHTML = "";
      
      const players = (state.players || []).map(p => ({
        ...p,
        drops: p.score !== undefined ? p.score : (p.drops !== undefined ? p.drops : 10)  // Use score from API as drops, fallback to drops field or 10
      }));
      
      // Sort active players by drops (highest first), with original index as tiebreaker
      const activePlayers = players
        .map((p, originalIndex) => ({ ...p, originalIndex }))
        .filter(p => !p.eliminated)
        .sort((a, b) => {
          if (b.drops !== a.drops) {
            return b.drops - a.drops; // Higher drops first
          }
          return a.originalIndex - b.originalIndex; // Same drops: earlier player first (seniority)
        });
      
      const eliminatedPlayers = players.filter(p => p.eliminated);
      
      // Detect newly eliminated players and play sound
      eliminatedPlayers.forEach(p => {
        if (!previouslyEliminatedIds.has(p.id)) {
          playSound('eliminated');
          previouslyEliminatedIds.add(p.id);
        }
      });
      
      // Calculate ranks for active players (consecutive ranking)
      let currentRank = 1;
      activePlayers.forEach((p, idx) => {
        if (idx > 0 && p.drops === activePlayers[idx - 1].drops) {
          // Same drops as previous player, same rank (don't increment currentRank)
          p.rank = activePlayers[idx - 1].rank;
        } else {
          // Different drops, assign current rank
          p.rank = currentRank;
          currentRank++; // Increment for next different score
        }
      });
      
      // Update active players list with ranks
      activePlayers.forEach((p) => {
        const row = document.createElement("div");
        row.className = "player-row";
        const main = document.createElement("div");
        main.className = "player-main";
        
        // Add rank badge
        const rank = document.createElement("div");
        rank.className = "player-rank";
        rank.textContent = `Rank ${p.rank}`;
        
        const dot = document.createElement("div");
        dot.className = "player-dot";
        const gradients = [
          "radial-gradient(circle at 30% 20%, #fecaca, #b91c1c)",
          "radial-gradient(circle at 30% 20%, #a7f3d0, #16a34a)",
          "radial-gradient(circle at 30% 20%, #bfdbfe, #1d4ed8)",
          "radial-gradient(circle at 30% 20%, #fed7aa, #ea580c)"
        ];
        dot.style.background = gradients[p.originalIndex % 4];
        const name = document.createElement("div");
        name.className = "player-name";
        name.textContent = p.name || p.id;
        const meta = document.createElement("div");
        meta.className = "player-meta";
        meta.textContent = `Pos: ${p.pos ?? "-"}`;
        main.appendChild(rank);
        main.appendChild(dot);
        main.appendChild(name);
        main.appendChild(meta);
        const pos = document.createElement("div");
        pos.className = "player-pos";
        pos.textContent = `\uD83D\uDCA7 ${p.drops ?? 0}`;
        row.appendChild(main);
        row.appendChild(pos);
        playersList.appendChild(row);
      });
      
      // Update eliminated players list with last rank
      const lastRank = activePlayers.length + eliminatedPlayers.length;
      eliminatedPlayers.forEach((p) => {
        const item = document.createElement("div");
        item.className = "eliminated-item";
        
        const rank = document.createElement("div");
        rank.className = "player-rank eliminated-rank";
        rank.textContent = `Rank ${lastRank}`;
        
        const tokenIcon = document.createElement("div");
        tokenIcon.className = "eliminated-token";
        const playerIndex = players.indexOf(p);
        const pawnImages = [
          "assets/pawns/pawn-red.svg",
          "assets/pawns/pawn-green.svg",
          "assets/pawns/pawn-blue.svg",
          "assets/pawns/pawn-yellow.svg"
        ];
        tokenIcon.style.backgroundImage = `url('${pawnImages[playerIndex % 4]}')`;
        
        const name = document.createElement("span");
        name.textContent = p.name || p.id;
        
        item.appendChild(rank);
        item.appendChild(tokenIcon);
        item.appendChild(name);
        eliminatedList.appendChild(item);
      });
      
      // Update eliminated count badge
      eliminatedCount.textContent = eliminatedPlayers.length;
      
      // Check for winner (only one player remaining)
      if (activePlayers.length === 1 && eliminatedPlayers.length > 0) {
        showWinner(activePlayers[0]);
      }

      // If a dice animation is currently playing on the client, queue the latest
      // polled state and DO NOT touch tokens at all (they are animating).
      if (isDiceAnimationPlaying) {
        console.debug('[live] updateUIFromState GÇö animation playing, queuing latest state');
        queuedLiveState = state; // keep only newest state
        // Keep a minimal event message while animation plays
        if (state.lastEvent && state.lastEvent.rolling) {
          eventLog.innerHTML = `<span class='event-highlight'>${state.lastEvent.playerName || state.lastEvent.playerId} is rollingGÇª</span>`;
        }
        return;
      }

      // Clear tokens for inactive players
      Object.keys(tokensByPlayerId).forEach(playerId => {
        const token = tokensByPlayerId[playerId];
        if (token && !players.find(p => p.id === playerId)) {
          token.style.display = 'none';
        }
      });

      // Check if dice is currently rolling BEFORE updating positions
      const isRolling = state.lastEvent && state.lastEvent.rolling === true;
      
      // Store position update function to call after dice animation
      const updatePlayerPositions = () => {
        // If a dice animation is playing, queue this state and do not move tokens now
        if (isDiceAnimationPlaying) {
          queuedLiveState = state;
          return;
        }
        players.forEach((p, idx) => {
          ensureTokenForPlayer(p);
          const token = tokensByPlayerId[p.id];
          
          // Mark eliminated players with special styling
          if (p.eliminated) {
            token.classList.add('eliminated');
          } else {
            token.classList.remove('eliminated');
            token.style.display = 'block';
          }
          
          // Get stored and new positions
          const previousPos = (token.dataset.tileIndex !== undefined && token.dataset.tileIndex !== '') ? parseInt(token.dataset.tileIndex) : null;
          const newPos = p.pos;

          // If position changed and we should animate, run the walking animation
          if (!p.eliminated && previousPos !== null && previousPos !== newPos) {
            // Use animateTokenWalk directly and update dataset only when animation completes
            animateTokenWalk(p.id, previousPos, newPos, idx, () => {
              const t = tokensByPlayerId[p.id];
              if (t) t.dataset.tileIndex = newPos;
            });
          } else {
            // No animation required GÇö position immediately and update dataset
            positionToken(p.id, newPos, idx, false);
            token.dataset.tileIndex = newPos;
          }
        });
      };

      // If rolling, don't touch tokens at all - they will be positioned after dice animation
      if (isRolling) {
        // Just ensure tokens exist, no positioning yet
        players.forEach((p, idx) => {
          ensureTokenForPlayer(p);
        });
      }

      if (state.lastEvent) {
        const e = state.lastEvent;
        
        // CRITICAL GUARD: If this event has dice values and we haven't set the animation flag yet,
        // or if animation is already playing, do NOT process anything
        if (e.dice1 && e.dice1 !== null && !e.rolling && !e.reset && !e.undo) {
          const eventId = `${e.playerId}-${e.dice1}-${e.dice2 || 0}-${e.tileIndex}`;
          const isNewEvent = !lastProcessedEvent || lastProcessedEvent !== eventId;
          
          // If this is a new dice roll event, set the flag IMMEDIATELY before anything else
          if (isNewEvent && !isDiceAnimationPlaying) {
            isDiceAnimationPlaying = true;
            console.debug('[live] EARLY GUARD: New dice event detected, flag set immediately');
          }
        }
        
        // Skip processing if lastEvent has empty playerId (happens after reset)
        if (!e.playerId || e.playerId === "") {
          eventLog.innerHTML = "Waiting for first roll...";
          updatePlayerPositions();
          return;
        }
        
        const playerName = e.playerName || e.playerId || "Player";
        const diceColor1 = e.diceColor1 || e.diceColor || null;
        const diceColor2 = e.diceColor2 || null;
        
        // Check if dice is currently rolling (from Android sensors)
        if (e.rolling === true) {
          // DICE IS PHYSICALLY ROLLING - Show rolling message and animate
          const rollingCount = e.rollingDiceCount || 1;
          const rollingText = rollingCount > 1 
            ? `${playerName} is rolling both dice...` 
            : `${playerName} is rolling the dice...`;
          eventLog.innerHTML = `<span class='event-highlight'>${rollingText}</span>`;
          
          // Trigger continuous rolling animation until we get rolling: false
          showRollingDice(playerName, diceColor1, diceColor2, e.dice1Rolling, e.dice2Rolling, e.dice1, e.dice2);
          // Note: Continue processing to keep tokens visible on board
        }
        
        // Dice has stopped - process the result (only if not currently rolling)
        if (!e.rolling) {
          // Skip dice animation for reset and undo events
          if (e.reset === true) {
            eventLog.innerHTML = "Game reset - Ready to play!";
            // Clear last processed event to allow new rolls
            lastProcessedEvent = null;
            // Cancel any ongoing dice animation and queued states
            isDiceAnimationPlaying = false;
            queuedLiveState = null;
            try {
              if (scoreboardDice1) scoreboardDice1.style.animation = 'none';
              if (scoreboardDice2) scoreboardDice2.style.animation = 'none';
            } catch (err) { /* ignore */ }
            updatePlayerPositions(); // Update positions immediately for reset
            return;
          }
          
          if (e.undo === true) {
            eventLog.innerHTML = `<span class='event-highlight'>Undo</span> - ${playerName} returns to previous position`;
            updatePlayerPositions(); // Update positions immediately for undo
            return;
          }
          
          // Skip if no dice values (e.g., initial state)
          if (!e.dice1) {
            eventLog.innerHTML = "Waiting for first roll...";
            updatePlayerPositions(); // Update positions immediately
            return;
          }
          
          // Ensure dice values are present before trying to animate
          if (e.dice1 === null || e.dice1 === undefined) {
            eventLog.innerHTML = "Waiting for first roll...";
            updatePlayerPositions(); // Update positions immediately
            return;
          }

          // Create a unique identifier for this event
          const eventId = `${e.playerId}-${e.dice1}-${e.dice2 || 0}-${e.tileIndex}`;
          const isNewEvent = !lastProcessedEvent || lastProcessedEvent !== eventId;
          
          if (isNewEvent) {
            // NEW ROLL - Flag already set by early guard above
            lastProcessedEvent = eventId;
            console.debug('[live] Processing new event, flag already set');
            
            eventLog.innerHTML = `<span class='event-highlight'>${playerName}</span> is rolling...`;
            
            // Clear any pending token movement timer from previous roll
            if (tokenMoveTimer) {
              clearTimeout(tokenMoveTimer);
              tokenMoveTimer = null;
            }
            
            // Ensure all tokens exist and are visible at CURRENT positions before dice animation
            players.forEach((p, idx) => {
              ensureTokenForPlayer(p);
              const token = tokensByPlayerId[p.id];
              if (p.eliminated) {
                token.style.display = 'none';
              } else {
                token.style.display = 'block';
              }
            });
            
            // Show 3D dice animation in scoreboard
            if (e.dice2 !== null && e.dice2 !== undefined) {
              // Double dice mode
              show3DDiceRoll(e.dice1, e.dice2, playerName, () => {
                // Update event log AFTER dice animation completes
                eventLog.innerHTML = `<span class='event-highlight'>${playerName}</span> rolled <span class='event-highlight'>${e.dice1}</span> and <span class='event-highlight'>${e.dice2}</span>, moved to <span class='event-highlight'>Tile ${e.tileIndex}</span>${e.chanceCardId ? ` and drew card <span class='event-highlight'>${e.chanceCardId}</span>.` : "."}`;
              }, diceColor1, diceColor2);
              
              // DELAYED TOKEN MOVEMENT: Wait 3 seconds after receiving API data before moving tokens
              // This ensures dice animation (2s) completes first with 1s buffer
              console.debug('[live] Starting 3s timer before token movement');
              tokenMoveTimer = setTimeout(() => {
                console.debug('[live] Timer complete - clearing animation flag and moving tokens now');
                isDiceAnimationPlaying = false;
                updatePlayerPositions();
                tokenMoveTimer = null;
              }, 3000);
            } else {
              // Single dice mode
              show3DDiceRoll(e.dice1, null, playerName, () => {
                // Update event log AFTER dice animation completes
                eventLog.innerHTML = `<span class='event-highlight'>${playerName}</span> rolled <span class='event-highlight'>${e.dice1}</span>, moved to <span class='event-highlight'>Tile ${e.tileIndex}</span>${e.chanceCardId ? ` and drew card <span class='event-highlight'>${e.chanceCardId}</span>.` : "."}`;
              }, diceColor1, diceColor2);
              
              // DELAYED TOKEN MOVEMENT: Wait 3 seconds after receiving API data before moving tokens
              // This ensures dice animation (2s) completes first with 1s buffer
              console.debug('[live] Starting 3s timer before token movement');
              tokenMoveTimer = setTimeout(() => {
                console.debug('[live] Timer complete - clearing animation flag and moving tokens now');
                isDiceAnimationPlaying = false;
                updatePlayerPositions();
                tokenMoveTimer = null;
              }, 3000);
            }
          } else {
            // SAME EVENT - Just show the static result (no animation)
            showStaticDice(e.dice1, e.dice2, playerName, diceColor1, diceColor2);
            eventLog.innerHTML = `<span class='event-highlight'>${playerName}</span> rolled <span class='event-highlight'>${e.dice1}</span>${e.dice2 !== null && e.dice2 !== undefined ? ` and <span class='event-highlight'>${e.dice2}</span>` : ''}, moved to <span class='event-highlight'>Tile ${e.tileIndex}</span>${e.chanceCardId ? ` and drew card <span class='event-highlight'>${e.chanceCardId}</span>.` : "."}`;
            // Positions already set, no need to animate again
          }
        }
      } else {
        eventLog.textContent = "Waiting for first drop...ª";
      }

      if (state.lastEvent && state.lastEvent.chanceCardId) {
        const id = state.lastEvent.chanceCardId;
        playSound('chance'); // Play chance card sound
        chanceImage.style.backgroundImage = `url('/assets/chance/${id}.jpg')`;
        chanceTitle.textContent = `Chance Card GÇô ${id}`;
        chanceText.textContent = (state.chanceDescriptions && state.chanceDescriptions[id]) || "Special event triggered by the board.";
        chanceCard.classList.add("visible");
        if (lastChanceTimeout) clearTimeout(lastChanceTimeout);
        lastChanceTimeout = setTimeout(() => chanceCard.classList.remove("visible"), 4500);
      } else {
        chanceCard.classList.remove("visible");
      }
    }

    async function fetchAndUpdate() {
      if (demoMode) return;
      if (!navigator.onLine) {
        console.log('Skipping fetch - offline');
        return;
      }
      
      let retryAttempt = 0;
      const maxRetries = 5;
      const retryDelays = [2000, 4000, 8000, 16000, 32000];  // Exponential backoff
      
      async function attemptFetch() {
        try {
          const res = await fetch(LIVE_STATE_URL, { cache: "no-store" });
          if (!res.ok) throw new Error("HTTP " + res.status);
          const state = await res.json();

          // Check if this is the first successful connection
          if (!connectionEstablished && state.players && state.players.length > 0) {
            connectionEstablished = true;
            onControllerConnected();
          }

          connStatus.textContent = "ONLINE";
          connStatus.classList.remove("badge-red");
          connStatus.classList.add("badge-green");
          modeStatus.textContent = "LIVE";
          
          // Hide reconnection overlay if visible
          hideReconnectionOverlay();
          
          // Hide loading overlay on first successful fetch
          if (!firstFetchComplete) {
            firstFetchComplete = true;
            loadingOverlay.classList.add('hidden');
          }
          
          // Reset retry counter on success
          retryAttempt = 0;
          
          // Update "Last Updated" timestamp
          const now = new Date();
          const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
          lastUpdatedEl.textContent = `Last updated: ${timeStr}`;
          
          updateUIFromState(state);
        } catch (err) {
          console.error("Live state error (attempt " + (retryAttempt + 1) + "/" + maxRetries + "):", err);
          
          if (retryAttempt < maxRetries) {
            // Show reconnection overlay
            showReconnectionOverlay(retryAttempt + 1, retryDelays[retryAttempt]);
            
            // Wait and retry
            await new Promise(resolve => setTimeout(resolve, retryDelays[retryAttempt]));
            retryAttempt++;
            return attemptFetch();  // Retry
          } else {
            // Max retries reached
            connStatus.textContent = "OFFLINE";
            connStatus.classList.remove("badge-green");
            connStatus.classList.add("badge-red");
            modeStatus.textContent = "DEMO";
            showReconnectionOverlay(maxRetries, null);  // Show permanent error
          }
        }
      }
      
      await attemptFetch();
    }

    // Start live polling interval only if not in demo mode
    let livePollingInterval;
    function startLivePolling() {
      if (!livePollingInterval) {
        livePollingInterval = setInterval(() => { 
          if (!demoMode) fetchAndUpdate(); 
        }, 2000);
      }
    }

    // Connection popup functions
    function showConnectionPopup() {
      connectionOverlay.classList.remove('hidden');
      // Start polling for live connection when popup is shown
      startLivePolling();
    }

    function hideConnectionPopup() {
      connectionOverlay.classList.add('hidden');
    }

    function onControllerConnected() {
      // Update popup status
      connectionIndicator.querySelector('.status-dot').classList.add('connected');
      connectionText.textContent = 'Controller Connected! ë';

      // Hide popup after 2 seconds
      setTimeout(() => {
        hideConnectionPopup();
      }, 2000);
    }
    
    // Reconnection overlay functions
    function showReconnectionOverlay(attempt, delayMs) {
      reconnectionOverlay.classList.remove('hidden');
      
      if (delayMs === null) {
        // Max retries reached
        reconnectionText.textContent = 'Connection lost - Max retries reached';
        reconnectionInfo.innerHTML = '<p style="color: var(--danger);">Unable to reach server. Please check your network connection.</p>';
      } else {
        reconnectionText.textContent = 'Attempting to reconnect...';
        retryAttemptEl.textContent = attempt;
        retryDelayEl.textContent = (delayMs / 1000).toFixed(0);
      }
    }
    
    function hideReconnectionOverlay() {
      reconnectionOverlay.classList.add('hidden');
    }

    // Dice animation function for board overlay (kept for compatibility)
    function showDiceRoll(value1, value2 = null) {
      if (!diceDisplay || !dice1El || !dice2El) return;
      
      // Single dice mode
      if (value2 === null) {
        dice1El.setAttribute('data-value', value1.toString());
        dice1El.classList.add('single');
        dice2El.style.display = 'none';
      } else {
        // Double dice mode
        dice1El.setAttribute('data-value', value1.toString());
        dice2El.setAttribute('data-value', value2.toString());
        dice1El.classList.remove('single');
        dice2El.style.display = 'flex';
      }
      
      // Show dice with animation
      diceDisplay.classList.remove('hidden');
      
      // Reset animation by removing and re-adding class
      dice1El.style.animation = 'none';
      if (value2 !== null) dice2El.style.animation = 'none';
      setTimeout(() => {
        dice1El.style.animation = '';
        if (value2 !== null) dice2El.style.animation = '';
      }, 10);
      
      // Hide after 2 seconds
      setTimeout(() => {
        diceDisplay.classList.add('hidden');
      }, 2000);
    }

    // Show winner celebration
    function showWinner(player) {
      playSound('winner');
      winnerName.textContent = player.name || player.id;
      winnerDrops.textContent = `=ƒÆº ${player.drops} drops`;
      winnerOverlay.classList.remove('hidden');
    }

    // Helper function to set dice dots color (all dots same color)
    function setDiceDotsColor(colorName) {
      const colorMap = {
        'red': '#ef4444',
        'green': '#22c55e',
        'blue': '#60a5fa',
        'yellow': '#eab308',
        'orange': '#f97316',
        'black': '#1f2937'
      };
      
      const hexColor = colorMap[colorName] || colorName;
      currentDiceColor = hexColor;
      
      // Update all dice dots
      const allDots = document.querySelectorAll('.dice-dot');
      allDots.forEach(dot => {
        dot.style.backgroundColor = hexColor;
      });
    }
    
    // Helper function to set individual colors for each die
    function setIndividualDiceColors(color1, color2 = null) {
      const colorMap = {
        'red': '#ef4444',
        'green': '#22c55e',
        'blue': '#60a5fa',
        'yellow': '#eab308',
        'orange': '#f97316',
        'black': '#1f2937'
      };
      
      const hexColor1 = colorMap[color1] || color1 || '#60a5fa';
      const hexColor2 = color2 ? (colorMap[color2] || color2) : hexColor1;
      
      // Update dice 1 dots
      const dice1Dots = scoreboardDice1.querySelectorAll('.dice-dot');
      dice1Dots.forEach(dot => {
        dot.style.backgroundColor = hexColor1;
      });
      
      // Update dice 2 dots
      const dice2Dots = scoreboardDice2.querySelectorAll('.dice-dot');
      dice2Dots.forEach(dot => {
        dot.style.backgroundColor = hexColor2;
      });
    }

    // Show rolling dice animation (continuous while Android sends rolling: true)
    // Show rolling dice animation (continuous while Android sends rolling: true)
function showRollingDice(
  playerName = "Player",
  diceColor1 = null,
  diceColor2 = null,
  dice1Rolling = true,
  dice2Rolling = true,
  value1 = null,
  value2 = null
) {
  if (!scoreboardDiceDisplay || !scoreboardDice1 || !scoreboardDice2 || !dicePlayerName) return;

  // Update dice colors if provided
  if (diceColor1 && diceColor2) {
    // Two different colors for 2-dice mode
    setIndividualDiceColors(diceColor1, diceColor2);
  } else if (diceColor1) {
    // Single color for both dice
    setDiceDotsColor(diceColor1);
  }

  // Update player name text based on which dice are rolling
  if (dice1Rolling && dice2Rolling) {
    dicePlayerName.textContent = `${playerName} is rolling both dice...`;
  } else if (dice1Rolling) {
    dicePlayerName.textContent = `${playerName} - die 1 rolling...`;
  } else if (dice2Rolling) {
    dicePlayerName.textContent = `${playerName} - die 2 rolling...`;
  } else {
    dicePlayerName.textContent = `${playerName} is rolling...`;
  }

  // Helper: same rotation map as in showStaticDice
  const getRotation = (value) => {
    const rotations = {
      1: 'rotateX(0deg) rotateY(0deg)',
      2: 'rotateX(-90deg) rotateY(0deg)',
      3: 'rotateX(0deg) rotateY(90deg)',
      4: 'rotateX(0deg) rotateY(-90deg)',
      5: 'rotateX(90deg) rotateY(0deg)',
      6: 'rotateX(180deg) rotateY(0deg)'
    };
    return rotations[value] || rotations[1];
  };

  // Make both dice visible during rolling
  scoreboardDiceDisplay.style.display = 'block';
  scoreboardDice1.classList.remove('single');
  scoreboardDice2.classList.remove('single');
  scoreboardDice2.style.display = 'block';

  // ---- Die 1 ----
  if (dice1Rolling === false && value1 != null) {
    // Die 1 has stopped: show its final face, no animation
    const faces1 = scoreboardDice1.querySelectorAll('.dice-face');
    faces1.forEach(face => {
      face.setAttribute('data-value', value1.toString());
    });
    scoreboardDice1.style.animation = 'none';
    scoreboardDice1.style.transform = getRotation(value1);
  } else if (dice1Rolling !== false) {
    // Die 1 still rolling
    scoreboardDice1.style.animation = 'dice-roll 0.5s linear infinite';
  } else {
    // Not rolling and no value GÇô keep idle
    scoreboardDice1.style.animation = 'none';
  }

  // ---- Die 2 ----
  if (value2 == null && !dice2Rolling) {
    // Single-die mode: hide second die
    scoreboardDice2.style.display = 'none';
    scoreboardDice2.style.animation = 'none';
  } else if (dice2Rolling === false && value2 != null) {
    // Die 2 has stopped: show its final face, no animation
    const faces2 = scoreboardDice2.querySelectorAll('.dice-face');
    faces2.forEach(face => {
      face.setAttribute('data-value', value2.toString());
    });
    scoreboardDice2.style.animation = 'none';
    scoreboardDice2.style.transform = getRotation(value2);
  } else if (dice2Rolling !== false) {
    // Die 2 still rolling
    scoreboardDice2.style.animation = 'dice-roll 0.5s linear infinite';
  } else {
    scoreboardDice2.style.animation = 'none';
  }
}

function showStaticDice(value1, value2 = null, playerName = "Player", diceColor1 = null, diceColor2 = null) {
      if (!scoreboardDiceDisplay || !scoreboardDice1 || !scoreboardDice2 || !dicePlayerName) return;
      
      // Update dice colors if provided
      if (diceColor1 && diceColor2) {
        setIndividualDiceColors(diceColor1, diceColor2);
      } else if (diceColor1) {
        setDiceDotsColor(diceColor1);
      }
      
      // Update player name text
      dicePlayerName.textContent = `${playerName} rolled ${value2 !== null ? value1 + ' & ' + value2 : value1}`;
      
      // Calculate rotation to show correct face
      const getRotation = (value) => {
        const rotations = {
          1: 'rotateX(0deg) rotateY(0deg)',
          2: 'rotateX(-90deg) rotateY(0deg)',
          3: 'rotateX(0deg) rotateY(90deg)',
          4: 'rotateX(0deg) rotateY(-90deg)',
          5: 'rotateX(90deg) rotateY(0deg)',
          6: 'rotateX(180deg) rotateY(0deg)'
        };
        return rotations[value] || rotations[1];
      };
      
      // Set dice faces to show final values
      const faces1 = scoreboardDice1.querySelectorAll('.dice-face');
      faces1.forEach(face => {
        face.setAttribute('data-value', value1.toString());
      });
      
      // Single or double dice mode
      if (value2 === null) {
        scoreboardDice1.classList.add('single');
        scoreboardDice2.style.display = 'none';
      } else {
        scoreboardDice1.classList.remove('single');
        scoreboardDice2.classList.remove('single');
        scoreboardDice2.style.display = 'block';
        
        // Set dice 2 faces to show final value
        const faces2 = scoreboardDice2.querySelectorAll('.dice-face');
        faces2.forEach(face => {
          face.setAttribute('data-value', value2.toString());
        });
      }
      
      // Remove any animation and set final rotation immediately
      scoreboardDice1.style.animation = 'none';
      scoreboardDice1.style.transform = getRotation(value1);
      if (value2 !== null) {
        scoreboardDice2.style.animation = 'none';
        scoreboardDice2.style.transform = getRotation(value2);
      }
    }

    // 3D Dice animation for scoreboard
    function show3DDiceRoll(value1, value2 = null, playerName = "Player", callback = null, diceColor1 = null, diceColor2 = null) {
      if (!scoreboardDiceDisplay || !scoreboardDice1 || !scoreboardDice2 || !dicePlayerName) return;
      // Defensive: if no dice value provided, do not play the animation
      if (value1 === null || value1 === undefined) {
        if (typeof callback === 'function') callback();
        return;
      }
      // Mark that the client is playing a dice animation so incoming polled
      // states won't move tokens until this animation completes.
      console.debug('[live] show3DDiceRoll START GÇö setting isDiceAnimationPlaying = true', value1, value2, playerName);
      isDiceAnimationPlaying = true;
      
      // Update dice colors if provided
      if (diceColor1 && diceColor2) {
        setIndividualDiceColors(diceColor1, diceColor2);
      } else if (diceColor1) {
        setDiceDotsColor(diceColor1);
      }
      
      // Play dice roll sound
      playSound('dice');
      
      // Update player name text
      dicePlayerName.textContent = `${playerName} rolling dice...`;
      
      // Calculate rotation to show correct face
      const getRotation = (value) => {
        const rotations = {
          1: 'rotateX(0deg) rotateY(0deg)',
          2: 'rotateX(-90deg) rotateY(0deg)',
          3: 'rotateX(0deg) rotateY(90deg)',
          4: 'rotateX(0deg) rotateY(-90deg)',
          5: 'rotateX(90deg) rotateY(0deg)',
          6: 'rotateX(180deg) rotateY(0deg)'
        };
        return rotations[value] || rotations[1];
      };
      
      // Reset dice faces to default 1-6 pattern for realistic rolling animation
      const defaultFaces1 = ['1', '6', '3', '4', '5', '2']; // front, back, right, left, top, bottom
      const faces1 = scoreboardDice1.querySelectorAll('.dice-face');
      faces1.forEach((face, idx) => {
        face.setAttribute('data-value', defaultFaces1[idx]);
      });
      
      // Single or double dice mode
      if (value2 === null) {
        scoreboardDice1.classList.add('single');
        scoreboardDice2.style.display = 'none';
      } else {
        scoreboardDice1.classList.remove('single');
        scoreboardDice2.classList.remove('single');
        scoreboardDice2.style.display = 'block';
        
        // Reset dice 2 faces to default pattern
        const faces2 = scoreboardDice2.querySelectorAll('.dice-face');
        faces2.forEach((face, idx) => {
          face.setAttribute('data-value', defaultFaces1[idx]);
        });
      }
      
      // Reset and trigger animation
      scoreboardDice1.style.animation = 'none';
      if (value2 !== null) scoreboardDice2.style.animation = 'none';
      
      setTimeout(() => {
        scoreboardDice1.style.animation = '';
        if (value2 !== null) scoreboardDice2.style.animation = '';
        
        // Just before animation ends, update all faces to show the correct rolled value
        setTimeout(() => {
          // Update all faces of dice 1 to show rolled value
          const faces1 = scoreboardDice1.querySelectorAll('.dice-face');
          faces1.forEach(face => {
            face.setAttribute('data-value', value1.toString());
          });
          
          // Update all faces of dice 2 if double dice mode
          if (value2 !== null) {
            const faces2 = scoreboardDice2.querySelectorAll('.dice-face');
            faces2.forEach(face => {
              face.setAttribute('data-value', value2.toString());
            });
          }
        }, 1800); // Update faces 200ms before animation ends (at 1.8s of 2s animation)
        
        // After animation, set final rotation to show correct face and keep it there
        setTimeout(() => {
          scoreboardDice1.style.transform = getRotation(value1);
          if (value2 !== null) {
            scoreboardDice2.style.transform = getRotation(value2);
          }
          // Animation finished, dice stays at rolled number
          dicePlayerName.textContent = `${playerName} rolled ${value2 !== null ? value1 + ' & ' + value2 : value1}`;

          // Clear animation guard, then run callback and apply any queued state
          console.debug('[live] show3DDiceRoll END GÇö clearing isDiceAnimationPlaying and applying queued state');
          isDiceAnimationPlaying = false;

          if (callback) callback();

          if (queuedLiveState) {
            const queued = queuedLiveState;
            queuedLiveState = null;
            // Apply queued state asynchronously to avoid re-entrancy issues
            setTimeout(() => updateUIFromState(queued), 20);
          }
        }, 2000); // Matches 2s animation
      }, 10);
    }

    let demoTick = 0;
    let currentPlayerIndex = 0; // Track which player is moving
    const demoPlayers = [
      { id: "P1", name: "Player 1", pos: 1, drops: 10, eliminated: false },
      { id: "P2", name: "Player 2", pos: 1, drops: 10, eliminated: false },
      { id: "P3", name: "Player 3", pos: 1, drops: 10, eliminated: false },
      { id: "P4", name: "Player 4", pos: 1, drops: 10, eliminated: false }
    ];
    // Updated with actual chance card IDs (1-20)
    const demoChanceIds = [null, "1", null, "6", null, "12", null, "17", null, "20", null, "3", null, "14"];

    // Tile effects: water drop changes per tile
    const tileEffects = {
      1: 0,   // Start Point
      2: -1,  // Sunny Patch
      3: 3,   // Rain Dock
      4: -1,  // Leak Lane
      5: -3,  // Storm Zone
      6: 1,   // Cloud Hill
      7: -4,  // Oil Spill Bay
      8: 0,   // Riverbank Road
      9: 'chance',  // Marsh Land
      10: -3, // Drought Desert
      11: 2,  // Clean Well
      12: -2, // Waste Dump
      13: 'chance', // Sanctuary Stop
      14: -2, // Sewage Drain Street
      15: 1,  // Filter Plant
      16: 'chance', // Mangrove Mile
      17: -2, // Heatwave Road
      18: 4,  // Spring Fountain
      19: 0,  // Eco Garden
      20: 0   // Great Reservoir
    };

    // Chance card effects
    const chanceCardEffects = {
      "1": 2,   // Fixed tap leak
      "2": 2,   // Rainwater harvested
      "3": 1,   // Planted trees
      "4": 1,   // Cool clouds
      "5": 1,   // Cleaned riverbank
      "6": 3,   // Discovered spring
      "7": 1,   // Saved wetland animal
      "8": 1,   // Reused RO water
      "9": 2,   // Bucket instead of shower
      "10": 2,  // Drip irrigation
      "11": 0,  // Skip next penalty
      "12": 0,  // Move forward 2 tiles
      "13": 0,  // Swap positions
      "14": 0,  // Water Shield
      "15": -1, // Left tap running
      "16": -1, // Bottle spilled
      "17": -3, // Pipe burst
      "18": -2, // Heat wave
      "19": -2, // Sewage contamination
      "20": -3  // Flood
    };

    function runDemoStep() {
      if (!demoMode) return;
      demoTick++;
      
      // Get current player, skip if eliminated
      let attempts = 0;
      while (attempts < demoPlayers.length) {
        const currentPlayer = demoPlayers[currentPlayerIndex];
        if (!currentPlayer.eliminated) break;
        currentPlayerIndex = (currentPlayerIndex + 1) % demoPlayers.length;
        attempts++;
      }
      
      // All players eliminated
      if (attempts >= demoPlayers.length) return;
      
      const currentPlayer = demoPlayers[currentPlayerIndex];
      
      // Roll single dice (1-6)
      const diceValue = 1 + Math.floor(Math.random() * 6);
      
      // Store old position to detect lap completion
      const oldPos = currentPlayer.pos;
      
      // Move current player
      const newPos = ((currentPlayer.pos - 1 + diceValue) % 20) + 1;
      currentPlayer.pos = newPos;
      
      // Check if player completed a lap (passed tile 1)
      if (oldPos > newPos || (oldPos + diceValue > 20)) {
        currentPlayer.drops += 5; // Lap bonus
      }
      
      // Show 3D dice animation (no callback needed in demo mode)
      show3DDiceRoll(diceValue, null, currentPlayer.name);
      
      // Apply tile effect
      const tileEffect = tileEffects[newPos];
      let chanceCardId = null;
      
      if (tileEffect === 'chance') {
        // Chance tile - draw random card
        chanceCardId = String(1 + Math.floor(Math.random() * 20));
        const cardEffect = chanceCardEffects[chanceCardId] || 0;
        currentPlayer.drops += cardEffect;
      } else if (typeof tileEffect === 'number') {
        currentPlayer.drops += tileEffect;
      }
      
      // Check for elimination
      if (currentPlayer.drops <= 0) {
        currentPlayer.drops = 0;
        currentPlayer.eliminated = true;
      }
      
      const state = {
        players: demoPlayers,
        lastEvent: {
          playerId: currentPlayer.id,
          playerName: currentPlayer.name,
          dice1: diceValue,
          dice2: null, // Single dice mode
          avg: diceValue,
          tileIndex: newPos,
          chanceCardId
        },
        chanceDescriptions: {
          "1": "You fixed a tap leak (+2 drops)",
          "2": "Rainwater harvested (+2 drops)",
          "3": "You planted two trees (+1 drop)",
          "4": "Cool clouds formed (+1 drop)",
          "5": "You cleaned a riverbank (+1 drop)",
          "6": "Discovered a tiny spring (+3 drops)",
          "7": "You saved a wetland animal (+1 drop)",
          "8": "You reused RO water (+1 drop)",
          "9": "Used bucket instead of shower (+2 drops)",
          "10": "Drip irrigation success (+2 drops)",
          "11": "Skip next penalty",
          "12": "Move forward 2 tiles",
          "13": "Swap positions with next player",
          "14": "Water Shield (next damage = 0)",
          "15": "You left tap running (-1 drop)",
          "16": "Your bottle spilled (-1 drop)",
          "17": "Pipe burst nearby (-3 drops)",
          "18": "Heat wave dries water (-2 drops)",
          "19": "Sewage contamination (-2 drops)",
          "20": "Flood washed away water (-3 drops)"
        }
      };
      
      connStatus.textContent = "OFFLINE";
      connStatus.classList.remove("badge-green");
      connStatus.classList.add("badge-red");
      updateUIFromState(state);
      
      // Move to next player
      currentPlayerIndex = (currentPlayerIndex + 1) % demoPlayers.length;
    }

    setInterval(runDemoStep, 5000); // Increased to 5 seconds for walking animation visibility

    window.addEventListener("load", () => {
      // Initialize connection popup elements
      connectionOverlay = document.getElementById("connectionOverlay");
      connectionIndicator = document.getElementById("connectionIndicator");
      connectionText = document.getElementById("connectionText");
      skipConnection = document.getElementById("skipConnection");
      
      // Initialize reconnection overlay elements
      reconnectionOverlay = document.getElementById("reconnectionOverlay");
      reconnectionText = document.getElementById("reconnectionText");
      retryAttemptEl = document.getElementById("retryAttempt");
      retryDelayEl = document.getElementById("retryDelay");
      reconnectionInfo = document.getElementById("reconnectionInfo");
      
      // Initialize welcome overlay
      const welcomeOverlay = document.getElementById("welcomeOverlay");
      const startDemoBtn = document.getElementById("startDemoBtn");
      
      // Initialize last updated element
      lastUpdatedEl = document.getElementById("lastUpdated");

      // Initialize disclaimer elements
      const smallScreenDisclaimer = document.getElementById("smallScreenDisclaimer");
      const dismissDisclaimer = document.getElementById("dismissDisclaimer");

      // Initialize dice elements
      diceDisplay = document.getElementById("diceDisplay");
      dice1El = document.getElementById("dice1");
      dice2El = document.getElementById("dice2");
      
      // Initialize scoreboard 3D dice elements
      scoreboardDiceDisplay = document.getElementById("scoreboardDiceDisplay");
      scoreboardDice1 = document.getElementById("scoreboardDice1");
      scoreboardDice2 = document.getElementById("scoreboardDice2");
      dicePlayerName = document.getElementById("dicePlayerName");

      // Show welcome overlay on load (user clicks button to start)
      welcomeOverlay.classList.remove("hidden");
      
      // Keep button handler for manual restart if needed
      startDemoBtn?.addEventListener('click', () => {
        welcomeOverlay.classList.add("hidden");
        demoMode = true;
        demoStatus.textContent = "ON";
        modeStatus.textContent = "DEMO";
        connStatus.textContent = "OFFLINE";
        connStatus.classList.remove("badge-green");
        connStatus.classList.add("badge-red");
      });
      
      // Show disclaimer on small screens with modified button
      if (window.innerWidth <= 768) {
        smallScreenDisclaimer.classList.remove("hidden");
        
        dismissDisclaimer?.addEventListener('click', () => {
          smallScreenDisclaimer.classList.add("hidden");
        });
      }

      skipConnection?.addEventListener('click', () => {
        demoMode = true;
        hideConnectionPopup();
        // Don't call fetchAndUpdate in demo mode, demo is already running
      });
      
      initTiles();
      computeTileCenters();
      // Start in top view
      const zoom = parseInt(zoomRange.value, 10) / 100;
      boardWrapper.style.transform = `scale(${zoom})`;
      board3d.style.transform = "rotateX(0deg) rotateY(0deg) rotateZ(0deg)";
      // Demo will start via interval, don't call runDemoStep() here
      
      // Network health monitoring
      let isOnline = navigator.onLine;
      
      window.addEventListener('online', () => {
        isOnline = true;
        console.log('Network connection restored');
        connStatus.textContent = 'ONLINE';
        connStatus.classList.remove('badge-red');
        connStatus.classList.add('badge-green');
        
        // Resume polling if not in demo mode
        if (!demoMode) {
          startLivePolling();
          fetchAndUpdate();  // Immediate fetch on reconnect
        }
      });
      
      window.addEventListener('offline', () => {
        isOnline = false;
        console.log('Network connection lost');
        connStatus.textContent = 'OFFLINE';
        connStatus.classList.remove('badge-green');
        connStatus.classList.add('badge-red');
        
        // Show reconnection overlay
        showReconnectionOverlay(0, null);
      });
    });
  </script>
</body>
</html>
</script>
<style>
  body.kid-mode .btn-small { font-size: 0.9rem; padding: 6px 10px; }
  body.kid-mode .board-controls input[type=range] { display: none; }
  .dev-controls { display: block; }
  body:not(.dev-mode) .dev-controls { display: none; }

  .toast-container { position: fixed; right: 12px; top: 12px; z-index: 3000; display: flex; flex-direction: column; gap: 8px; }
  .toast { background: rgba(15,23,42,0.95); border: 1px solid rgba(148,163,184,0.4); color: #eef2ff; padding: 8px 12px; border-radius: 8px; box-shadow: 0 6px 20px rgba(0,0,0,0.5); animation: toastIn .2s ease-out; }
  @keyframes toastIn { from { opacity: 0; transform: translateY(-6px); } to { opacity: 1; transform: translateY(0); } }

  .tutorial-overlay { position: fixed; inset: 0; background: rgba(2,6,23,0.75); display: flex; align-items: center; justify-content: center; z-index: 2500; }
  .tutorial-overlay.hidden { display: none; }
  .tutorial-card { background: linear-gradient(135deg,#0f172a,#020617); border: 1px solid rgba(148,163,184,0.4); border-radius: 12px; padding: 16px; width: min(420px, 90vw); color: #eef2ff; }
  .tutorial-title { font-weight: 600; margin-bottom: 8px; }
  .tutorial-steps { margin: 0 0 12px 18px; }

  /* Connection Popup */
  .connection-overlay { position: fixed; inset: 0; background: rgba(2,6,23,0.9); display: flex; align-items: center; justify-content: center; z-index: 2600; }
  .connection-overlay.hidden { display: none; }
  .connection-card { background: linear-gradient(135deg,#0f172a,#020617); border: 2px solid var(--accent); border-radius: 16px; padding: 24px; width: min(480px, 90vw); color: #eef2ff; box-shadow: 0 20px 60px rgba(0,0,0,0.8); }
  .connection-title { font-size: 1.3rem; font-weight: 700; text-align: center; margin-bottom: 20px; color: var(--accent); }
  .connection-content { display: flex; flex-direction: column; gap: 20px; }
  .connection-status { text-align: center; }
  .status-indicator { display: flex; align-items: center; justify-content: center; gap: 12px; padding: 16px; background: rgba(15,23,42,0.5); border-radius: 12px; border: 1px solid rgba(148,163,184,0.3); }
  .status-dot { width: 16px; height: 16px; border-radius: 50%; background: var(--danger); box-shadow: 0 0 12px rgba(249,115,115,0.6); animation: pulse 2s infinite; }
  .status-dot.connected { background: var(--success); box-shadow: 0 0 12px rgba(74,222,128,0.8); animation: none; }
  .connection-instructions { background: rgba(15,23,42,0.3); padding: 16px; border-radius: 8px; border-left: 4px solid var(--accent); }
  .connection-instructions p { margin: 8px 0; font-size: 0.9rem; }
  .connection-actions { text-align: center; }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  
  /* Spinner for reconnection */
  .spinner {
    width: 24px;
    height: 24px;
    border: 3px solid rgba(64, 224, 208, 0.3);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  .reconnection-info {
    background: rgba(15,23,42,0.3);
    padding: 16px;
    border-radius: 8px;
    border-left: 4px solid var(--accent);
  }
  
  .reconnection-info p {
    margin: 8px 0;
    font-size: 0.9rem;
  }

  /* Dice Display */
  .dice-display {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    pointer-events: none;
  }
  .dice-display.hidden { display: none; }
  .dice-container {
    display: flex;
    gap: 20px;
    animation: diceAppear 0.3s ease-out;
  }
  .dice {
    width: 80px;
    height: 80px;
    background: linear-gradient(135deg, #ffffff, #e0e7ff);
    border: 3px solid var(--accent);
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2.5rem;
    font-weight: bold;
    color: #1e293b;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    animation: diceRoll 0.6s ease-in-out;
  }
  .dice.single {
    width: 100px;
    height: 100px;
    font-size: 3rem;
  }
  @keyframes diceAppear {
    from { opacity: 0; transform: scale(0.5); }
    to { opacity: 1; transform: scale(1); }
  }
  @keyframes diceRoll {
    0% { transform: rotateX(0deg) rotateY(0deg); }
    25% { transform: rotateX(180deg) rotateY(90deg); }
    50% { transform: rotateX(360deg) rotateY(180deg); }
    75% { transform: rotateX(540deg) rotateY(270deg); }
    100% { transform: rotateX(720deg) rotateY(360deg); }
  }
  @keyframes diceFadeOut {
    from { opacity: 1; transform: scale(1); }
    to { opacity: 0; transform: scale(0.8); }
  }

  /* 3D Dice for Scoreboard */
  .scoreboard-dice-display {
    margin: 8px 0;
    padding: 8px;
    background: rgba(15, 23, 42, 0.3);
    border-radius: 6px;
    border: 1px solid rgba(148, 163, 184, 0.2);
  }
  
  .dice-player-name {
    text-align: center;
    font-size: 0.75rem;
    color: var(--accent);
    margin-bottom: 6px;
    font-weight: 600;
    letter-spacing: 0.05em;
  }
  
  .dice-3d-container {
    display: flex;
    gap: 10px;
    justify-content: center;
    align-items: center;
    perspective: 800px;
  }
  
  .dice-3d {
    width: 35px;
    height: 35px;
    position: relative;
    transform-style: preserve-3d;
    animation: rollDice3D 2s ease-out;
  }
  
  .dice-3d.single {
    width: 40px;
    height: 40px;
  }
  
  .dice-face {
    position: absolute;
    width: 35px;
    height: 35px;
    background: linear-gradient(135deg, #ffffff, #e0e7ff);
    border: 2px solid var(--accent);
    border-radius: 6px;
    display: grid;
    grid-template-areas: 
      "a . c"
      "e g f"
      "d . b";
    padding: 4px;
    gap: 1px;
    box-shadow: inset 0 2px 8px rgba(0,0,0,0.1);
  }
  
  .dice-3d.single .dice-face {
    width: 40px;
    height: 40px;
    padding: 5px;
  }
  
  /* Dice dots */
  .dice-dot {
    width: 6px;
    height: 6px;
    background: #1e293b;
    border-radius: 50%;
    box-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }
  
  .dice-3d.single .dice-dot {
    width: 7px;
    height: 7px;
  }
  
  .dice-dot:nth-child(1) { grid-area: a; }
  .dice-dot:nth-child(2) { grid-area: b; }
  .dice-dot:nth-child(3) { grid-area: c; }
  .dice-dot:nth-child(4) { grid-area: d; }
  .dice-dot:nth-child(5) { grid-area: e; }
  .dice-dot:nth-child(6) { grid-area: f; }
  .dice-dot:nth-child(7) { grid-area: g; }
  
  /* Dice value patterns */
  .dice-face[data-value="1"] .dice-dot:nth-child(7) { display: block; }
  .dice-face[data-value="1"] .dice-dot:not(:nth-child(7)) { display: none; }
  
  .dice-face[data-value="2"] .dice-dot:nth-child(1),
  .dice-face[data-value="2"] .dice-dot:nth-child(2) { display: block; }
  .dice-face[data-value="2"] .dice-dot:not(:nth-child(1)):not(:nth-child(2)) { display: none; }
  
  .dice-face[data-value="3"] .dice-dot:nth-child(1),
  .dice-face[data-value="3"] .dice-dot:nth-child(7),
  .dice-face[data-value="3"] .dice-dot:nth-child(2) { display: block; }
  .dice-face[data-value="3"] .dice-dot:not(:nth-child(1)):not(:nth-child(7)):not(:nth-child(2)) { display: none; }
  
  .dice-face[data-value="4"] .dice-dot:nth-child(1),
  .dice-face[data-value="4"] .dice-dot:nth-child(2),
  .dice-face[data-value="4"] .dice-dot:nth-child(3),
  .dice-face[data-value="4"] .dice-dot:nth-child(4) { display: block; }
  .dice-face[data-value="4"] .dice-dot:nth-child(n+5) { display: none; }
  
  .dice-face[data-value="5"] .dice-dot:nth-child(1),
  .dice-face[data-value="5"] .dice-dot:nth-child(2),
  .dice-face[data-value="5"] .dice-dot:nth-child(3),
  .dice-face[data-value="5"] .dice-dot:nth-child(4),
  .dice-face[data-value="5"] .dice-dot:nth-child(7) { display: block; }
  .dice-face[data-value="5"] .dice-dot:nth-child(5),
  .dice-face[data-value="5"] .dice-dot:nth-child(6) { display: none; }
  
  .dice-face[data-value="6"] .dice-dot:nth-child(1),
  .dice-face[data-value="6"] .dice-dot:nth-child(2),
  .dice-face[data-value="6"] .dice-dot:nth-child(3),
  .dice-face[data-value="6"] .dice-dot:nth-child(4),
  .dice-face[data-value="6"] .dice-dot:nth-child(5),
  .dice-face[data-value="6"] .dice-dot:nth-child(6) { display: block; }
  .dice-face[data-value="6"] .dice-dot:nth-child(7) { display: none; }
  
  /* Position each face of the cube */
  .dice-front  { transform: rotateY(0deg) translateZ(17.5px); }
  .dice-back   { transform: rotateY(180deg) translateZ(17.5px); }
  .dice-right  { transform: rotateY(90deg) translateZ(17.5px); }
  .dice-left   { transform: rotateY(-90deg) translateZ(17.5px); }
  .dice-top    { transform: rotateX(90deg) translateZ(17.5px); }
  .dice-bottom { transform: rotateX(-90deg) translateZ(17.5px); }
  
  .dice-3d.single .dice-front  { transform: rotateY(0deg) translateZ(20px); }
  .dice-3d.single .dice-back   { transform: rotateY(180deg) translateZ(20px); }
  .dice-3d.single .dice-right  { transform: rotateY(90deg) translateZ(20px); }
  .dice-3d.single .dice-left   { transform: rotateY(-90deg) translateZ(20px); }
  .dice-3d.single .dice-top    { transform: rotateX(90deg) translateZ(20px); }
  .dice-3d.single .dice-bottom { transform: rotateX(-90deg) translateZ(20px); }
  
  @keyframes rollDice3D {
    0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
    25% { transform: rotateX(360deg) rotateY(180deg) rotateZ(90deg); }
    50% { transform: rotateX(720deg) rotateY(360deg) rotateZ(180deg); }
    75% { transform: rotateX(1080deg) rotateY(540deg) rotateZ(270deg); }
    100% { transform: rotateX(1440deg) rotateY(720deg) rotateZ(360deg); }
  }

  .player-token.token-moving { animation: settle .25s ease-out; }
  @keyframes settle { 0% { transform: translate(-50%, -50%) scale(1.06); } 100% { transform: translate(-50%, -50%) scale(1.0); } }
</style>
<script>
  // Mode toggles and helpers
  const kidToggle = document.getElementById('kidToggle');
  const devToggle = document.getElementById('devToggle');
  const helpBtn   = document.getElementById('helpBtn');
  const kidStatus = document.getElementById('kidStatus');
  const devStatus = document.getElementById('devStatus');
  const tutorialOverlay = document.getElementById('tutorialOverlay');
  const closeTutorial = document.getElementById('closeTutorial');
  const toastContainer = document.getElementById('toastContainer');

  function showToast(msg) {
    const el = document.createElement('div');
    el.className = 'toast';
    el.textContent = msg;
    toastContainer.appendChild(el);
    setTimeout(() => el.remove(), 2500);
  }

  kidToggle?.addEventListener('click', () => {
    document.body.classList.toggle('kid-mode');
    const on = document.body.classList.contains('kid-mode');
    kidStatus.textContent = on ? 'ON' : 'OFF';
    showToast(on ? 'Kid Mode enabled' : 'Kid Mode disabled');
  });

  devToggle?.addEventListener('click', () => {
    document.body.classList.toggle('dev-mode');
    const on = document.body.classList.contains('dev-mode');
    devStatus.textContent = on ? 'ON' : 'OFF';
    showToast(on ? 'Dev Controls visible' : 'Dev Controls hidden');
  });

  helpBtn?.addEventListener('click', () => {
    tutorialOverlay.classList.remove('hidden');
  });
  closeTutorial?.addEventListener('click', () => {
    tutorialOverlay.classList.add('hidden');
  });

  // Snap animation hook: wrap existing positionToken
  const originalPositionToken = window.positionToken;
  if (typeof originalPositionToken === 'function') {
    window.positionToken = function(playerId, tileIndex, offsetIndex) {
      originalPositionToken(playerId, tileIndex, offsetIndex);
      const token = tokensByPlayerId[playerId];
      if (token) {
        token.classList.add('token-moving');
        setTimeout(() => token.classList.remove('token-moving'), 250);
      }
    };
  }
</script>
<style>
  .settings-panel { position: fixed; right: 0; top: 0; height: 100vh; width: min(340px, 86vw); background: rgba(2,6,23,0.96); border-left: 1px solid rgba(148,163,184,0.35); box-shadow: -10px 0 30px rgba(0,0,0,0.5); z-index: 2800; backdrop-filter: blur(6px); }
  .settings-panel.hidden { display: none; }
  .settings-content { padding: 12px; color: #eef2ff; }
  .settings-title { font-weight: 600; margin-bottom: 8px; }
  #settingsBtn { margin-left: auto; }
  .settings-section { margin-bottom: 10px; }
  .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin: 6px 0; }

  /* Full-screen board layout */
  .layout { height: calc(100vh - 60px); display: grid; grid-template-columns: 1fr auto; gap: 0; margin: 0; }
  .board-card, .perspective-wrapper { height: 100%; }
  .board-card { margin: 0; border-radius: 0; }

  /* Compact score panel */
  .side-card { width: 280px; border-left: 1px solid rgba(148,163,184,0.25); background: rgba(2,6,23,0.6); }
  body.kid-mode .side-card { width: 300px; }
</style>
<script>
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsPanel = document.getElementById('settingsPanel');
  const settingsBackdrop = document.getElementById('settingsBackdrop');
  const closeSettings ument.getElementById('closeSettings');
  
  settingsBtn?.addEventListener('click', () => {
    settingsPanel.classList.toggle('hidden');
    settingsBackdrop.classList.toggle('hidden');
  });
  
  closeSettings?.addEventListener('click', () => {
    settingsPanel.classList.add('hidden');
    settingsBackdrop.classList.add('hidden');
  });
  
  // Close en clicking on backdrop
  settingsBackdrop?.addEventListener('click', () => {
    settingsPanel.classList.add('hidden');
    settingsBackdrop.classList.add('hidden');
  });
</script>


